{
"version":3,
"file":"js_test.js",
"sourceRoot":"file://",
"sources":["/usr/lib/haxe/std/js/_std/EReg.hx","/usr/lib/haxe/std/js/_std/HxOverrides.hx","/usr/lib/haxe/std/Lambda.hx","/usr/lib/haxe/std/List.hx","/usr/lib/haxe/std/js/_std/Std.hx","/usr/lib/haxe/std/StringBuf.hx","/usr/lib/haxe/std/StringTools.hx","/usr/lib/haxe/lib/buddy/0,10,2/buddy/BuddySuite.hx","/home/as3boyan/HIDE-atom-shell/test/TestMain.hx","/usr/lib/haxe/lib/buddy/0,10,2/buddy/internal/SuiteBuilder.hx","/usr/lib/haxe/lib/buddy/0,10,2/buddy/GenerateMain.hx","/usr/lib/haxe/std/js/_std/Type.hx","/usr/lib/haxe/lib/buddy/0,10,2/buddy/Should.hx","/usr/lib/haxe/lib/buddy/0,10,2/buddy/SuitesRunner.hx","/usr/lib/haxe/lib/buddy/0,10,2/buddy/internal/SuiteRunner.hx","/usr/lib/haxe/lib/buddy/0,10,2/buddy/internal/sys/NodeJs.hx","/usr/lib/haxe/lib/buddy/0,10,2/buddy/reporting/ConsoleReporter.hx","/usr/lib/haxe/lib/buddy/0,10,2/buddy/tools/AsyncTools.hx","/usr/lib/haxe/std/haxe/CallStack.hx","/usr/lib/haxe/std/haxe/Log.hx","/usr/lib/haxe/std/haxe/Timer.hx","/usr/lib/haxe/std/haxe/rtti/Meta.hx","/usr/lib/haxe/std/js/Boot.hx","/usr/lib/haxe/lib/promhx/1,0,6/src/main/promhx/Deferred.hx","/usr/lib/haxe/lib/promhx/1,0,6/src/main/promhx/base/AsyncBase.hx","/usr/lib/haxe/lib/promhx/1,0,6/src/main/promhx/Promise.hx","/usr/lib/haxe/lib/promhx/1,0,6/src/main/promhx/Stream.hx","/usr/lib/haxe/lib/promhx/1,0,6/src/main/promhx/PublicStream.hx","/usr/lib/haxe/lib/promhx/1,0,6/src/main/promhx/base/EventLoop.hx","/usr/lib/haxe/std/Math.hx","/home/as3boyan/HIDE-atom-shell/externs/haxe-js-kit/npm/Package.hx","/home/as3boyan/HIDE-atom-shell/externs/haxe-js-kit/js/Node.hx"],
"sourcesContent":["/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:coreApi class EReg {\n\n\tvar r : Dynamic;\n\n\tpublic function new( r : String, opt : String ) : Void {\n\t\topt = opt.split(\"u\").join(\"\"); // 'u' (utf8) depends on page encoding\n\t\tthis.r = untyped __new__(\"RegExp\",r,opt);\n\t}\n\n\tpublic function match( s : String ) : Bool {\n\t\tif( r.global ) r.lastIndex = 0;\n\t\tr.m = r.exec(s);\n\t\tr.s = s;\n\t\treturn (r.m != null);\n\t}\n\n\tpublic function matched( n : Int ) : String {\n\t\treturn if( r.m != null && n >= 0 && n < r.m.length ) r.m[n] else throw \"EReg::matched\";\n\t}\n\n\tpublic function matchedLeft() : String {\n\t\tif( r.m == null ) throw \"No string matched\";\n\t\treturn r.s.substr(0,r.m.index);\n\t}\n\n\tpublic function matchedRight() : String {\n\t\tif( r.m == null ) throw \"No string matched\";\n\t\tvar sz = r.m.index+r.m[0].length;\n\t\treturn r.s.substr(sz,r.s.length-sz);\n\t}\n\n\tpublic function matchedPos() : { pos : Int, len : Int } {\n\t\tif( r.m == null ) throw \"No string matched\";\n\t\treturn { pos : r.m.index, len : r.m[0].length };\n\t}\n\n\tpublic function matchSub( s : String, pos : Int, len : Int = -1):Bool {\n\t\treturn if (r.global) {\n\t\t\tr.lastIndex = pos;\n\t\t\tr.m = r.exec(len < 0 ? s : s.substr(0, pos + len));\n\t\t\tvar b = r.m != null;\n\t\t\tif (b) {\n\t\t\t\tr.s = s;\n\t\t\t}\n\t\t\tb;\n\t\t} else {\n\t\t\t// TODO: check some ^/$ related corner cases\n\t\t\tvar b = match( len < 0 ? s.substr(pos) : s.substr(pos,len) );\n\t\t\tif (b) {\n\t\t\t\tr.s = s;\n\t\t\t\tr.m.index += pos;\n\t\t\t}\n\t\t\tb;\n\t\t}\n\t}\n\n\tpublic function split( s : String ) : Array<String> {\n\t\t// we can't use directly s.split because it's ignoring the 'g' flag\n\t\tvar d = \"#__delim__#\";\n\t\treturn untyped s.replace(r,d).split(d);\n\t}\n\n\tpublic function replace( s : String, by : String ) : String {\n\t\treturn untyped s.replace(r,by);\n\t}\n\n\tpublic function map( s : String, f : EReg -> String ) : String {\n\t\tvar offset = 0;\n\t\tvar buf = new StringBuf();\n\t\tdo {\n\t\t\tif (offset >= s.length)\n\t\t\t\tbreak;\n\t\t\telse if (!matchSub(s, offset)) {\n\t\t\t\tbuf.add(s.substr(offset));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvar p = matchedPos();\n\t\t\tbuf.add(s.substr(offset, p.pos - offset));\n\t\t\tbuf.add(f(this));\n\t\t\tif (p.len == 0) {\n\t\t\t\tbuf.add(s.substr(p.pos, 1));\n\t\t\t\toffset = p.pos + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t\toffset = p.pos + p.len;\n\t\t} while (r.global);\n\t\tif (!r.global && offset > 0 && offset < s.length)\n\t\t\tbuf.add(s.substr(offset));\n\t\treturn buf.toString();\n\t}\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:noDoc\nclass HxOverrides {\n\n\tstatic function dateStr( date :Date ) : String {\n\t\tvar m = date.getMonth() + 1;\n\t\tvar d = date.getDate();\n\t\tvar h = date.getHours();\n\t\tvar mi = date.getMinutes();\n\t\tvar s = date.getSeconds();\n\t\treturn date.getFullYear()\n\t\t\t+\"-\"+(if( m < 10 ) \"0\"+m else \"\"+m)\n\t\t\t+\"-\"+(if( d < 10 ) \"0\"+d else \"\"+d)\n\t\t\t+\" \"+(if( h < 10 ) \"0\"+h else \"\"+h)\n\t\t\t+\":\"+(if( mi < 10 ) \"0\"+mi else \"\"+mi)\n\t\t\t+\":\"+(if( s < 10 ) \"0\"+s else \"\"+s);\n\t}\n\n\tstatic function strDate( s : String ) : Date {\n\t\tswitch( s.length ) {\n\t\tcase 8: // hh:mm:ss\n\t\t\tvar k = s.split(\":\");\n\t\t\tvar d : Date = untyped __new__(Date);\n\t\t\tuntyped d[\"setTime\"](0);\n\t\t\tuntyped d[\"setUTCHours\"](k[0]);\n\t\t\tuntyped d[\"setUTCMinutes\"](k[1]);\n\t\t\tuntyped d[\"setUTCSeconds\"](k[2]);\n\t\t\treturn d;\n\t\tcase 10: // YYYY-MM-DD\n\t\t\tvar k = s.split(\"-\");\n\t\t\treturn new Date(cast k[0],cast untyped k[1] - 1,cast k[2],0,0,0);\n\t\tcase 19: // YYYY-MM-DD hh:mm:ss\n\t\t\tvar k = s.split(\" \");\n\t\t\tvar y = k[0].split(\"-\");\n\t\t\tvar t = k[1].split(\":\");\n\t\t\treturn new Date(cast y[0],cast untyped y[1] - 1,cast y[2],cast t[0],cast t[1],cast t[2]);\n\t\tdefault:\n\t\t\tthrow \"Invalid date format : \" + s;\n\t\t}\n\t}\n\n\tstatic function cca( s : String, index : Int ) : Null<Int> {\n\t\t#if mt\n\t\tvar x = (cast s).cca(index);\n\t\t#else\n\t\tvar x = (cast s).charCodeAt(index);\n\t\t#end\n\t\tif( x != x ) // fast isNaN\n\t\t\treturn untyped undefined; // isNaN will still return true\n\t\treturn x;\n\t}\n\n\tstatic function substr( s : String, pos : Int, ?len : Int ) : String {\n\t\tif( pos != null && pos != 0 && len != null && len < 0 ) return \"\";\n\t\tif( len == null ) len = s.length;\n\t\tif( pos < 0 ){\n\t\t\tpos = s.length + pos;\n\t\t\tif( pos < 0 ) pos = 0;\n\t\t}else if( len < 0 ){\n\t\t\tlen = s.length + len - pos;\n\t\t}\n\n\t\treturn (untyped s).substr(pos, len);\n\t}\n\n\tstatic function indexOf<T>( a : Array<T>, obj : T, i : Int) {\n\t\tvar len = a.length;\n\t\tif (i < 0) {\n\t\t\ti += len;\n\t\t\tif (i < 0) i = 0;\n\t\t}\n\t\twhile (i < len)\n\t\t{\n\t\t\tif (untyped __js__(\"a[i] === obj\"))\n\t\t\t\treturn i;\n\t\t\ti++;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic function lastIndexOf<T>( a : Array<T>, obj : T, i : Int) {\n\t\tvar len = a.length;\n\t\tif (i >= len)\n\t\t\ti = len - 1;\n\t\telse if (i < 0)\n\t\t\ti += len;\n\t\twhile (i >= 0)\n\t\t{\n\t\t\tif (untyped __js__(\"a[i] === obj\"))\n\t\t\t\treturn i;\n\t\t\ti--;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic function remove<T>( a : Array<T>, obj : T ) {\n\t\tvar i = a.indexOf(obj);\n\t\tif( i == -1 ) return false;\n\t\ta.splice(i,1);\n\t\treturn true;\n\t}\n\n\tstatic function iter<T>( a : Array<T> ) : Iterator<T> untyped {\n\t\treturn {\n\t\t\tcur : 0,\n\t\t\tarr : a,\n\t\t\thasNext : function() {\n\t\t\t\treturn __this__.cur < __this__.arr.length;\n\t\t\t},\n\t\t\tnext : function() {\n\t\t\t\treturn __this__.arr[__this__.cur++];\n\t\t\t}\n\t\t};\n\t}\n\n\tstatic function __init__() untyped {\n#if !js_es5\n\t\t__feature__('HxOverrides.indexOf', if( Array.prototype.indexOf ) __js__(\"HxOverrides\").indexOf = function(a,o,i) return Array.prototype.indexOf.call(a, o, i));\n\t\t__feature__('HxOverrides.lastIndexOf', if( Array.prototype.lastIndexOf ) __js__(\"HxOverrides\").lastIndexOf = function(a,o,i) return Array.prototype.lastIndexOf.call(a, o, i));\n#end\n\n#if mt\n\t\tif( String.prototype.cca == null ) String.prototype.cca = String.prototype.charCodeAt;\n#end\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\n/**\n\tThe `Lambda` class is a collection of methods to support functional\n\tprogramming. It is ideally used with 'using Lambda' and then acts as an\n\textension to Iterable types.\n\n\tOn static platforms, working with the Iterable structure might be slower\n\tthan performing the operations directly on known types, such as Array and\n\tList.\n\n\tIf the first argument to any of the methods is null, the result is\n\tunspecified.\n**/\nclass Lambda {\n\n\t/**\n\t\tCreates an Array from Iterable `it`.\n\n\t\tIf `it` is an Array, this function returns a copy of it.\n\t**/\n\tpublic static function array<A>( it : Iterable<A> ) : Array<A> {\n\t\tvar a = new Array<A>();\n\t\tfor(i in it)\n\t\t\ta.push(i);\n\t\treturn a;\n\t}\n\n\t/**\n\t\tCreates a List form Iterable `it`.\n\n\t\tIf `it` is a List, this function returns a copy of it.\n\t**/\n\tpublic static function list<A>( it : Iterable<A> ) : List<A> {\n\t\tvar l = new List<A>();\n\t\tfor(i in it)\n\t\t\tl.add(i);\n\t\treturn l;\n\t}\n\n\t/**\n\t\tCreates a new List by applying function `f` to all elements of `it`.\n\n\t\tThe order of elements is preserved.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function map<A,B>( it : Iterable<A>, f : A -> B ) : List<B> {\n\t\tvar l = new List<B>();\n\t\tfor( x in it )\n\t\t\tl.add(f(x));\n\t\treturn l;\n\t}\n\n\t/**\n\t\tSimilar to map, but also passes the index of each element to `f`.\n\n\t\tThe order of elements is preserved.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function mapi<A,B>( it : Iterable<A>, f : Int -> A -> B ) : List<B> {\n\t\tvar l = new List<B>();\n\t\tvar i = 0;\n\t\tfor( x in it )\n\t\t\tl.add(f(i++,x));\n\t\treturn l;\n\t}\n\n\t/**\n\t\tTells if `it` contains `elt`.\n\n\t\tThis function returns true as soon as an element is found which is equal\n\t\tto `elt` according to the `==` operator.\n\n\t\tIf no such element is found, the result is false.\n\t**/\n\tpublic static function has<A>( it : Iterable<A>, elt : A ) : Bool {\n\t\tfor( x in it )\n\t\t\tif( x == elt )\n\t\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\t/**\n\t\tTells if `it` contains an element for which `f` is true.\n\n\t\tThis function returns true as soon as an element is found for which a\n\t\tcall to `f` returns true.\n\n\t\tIf no such element is found, the result is false.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function exists<A>( it : Iterable<A>, f : A -> Bool ) {\n\t\tfor( x in it )\n\t\t\tif( f(x) )\n\t\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\t/**\n\t\tTells if `f` is true for all elements of `it`.\n\n\t\tThis function returns false as soon as an element is found for which a\n\t\tcall to `f` returns false.\n\n\t\tIf no such element is found, the result is true.\n\n\t\tIn particular, this function always returns true if `it` is empty.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function foreach<A>( it : Iterable<A>, f : A -> Bool ) {\n\t\tfor( x in it )\n\t\t\tif( !f(x) )\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t/**\n\t\tCalls `f` on all elements of `it`, in order.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function iter<A>( it : Iterable<A>, f : A -> Void ) {\n\t\tfor( x in it )\n\t\t\tf(x);\n\t}\n\n\t/**\n\t\tReturns a List containing those elements of `it` for which `f` returned\n\t\ttrue.\n\n\t\tIf `it` is empty, the result is the empty List even if `f` is null.\n\n\t\tOtherwise if `f` is null, the result is unspecified.\n\t**/\n\tpublic static function filter<A>( it : Iterable<A>, f : A -> Bool ) {\n\t\tvar l = new List<A>();\n\t\tfor( x in it )\n\t\t\tif( f(x) )\n\t\t\t\tl.add(x);\n\t\treturn l;\n\t}\n\n\t/**\n\t\tFunctional fold on Iterable `it`, using function `f` with start argument\n\t\t`first`.\n\n\t\tIf `it` has no elements, the result is `first`.\n\n\t\tOtherwise the first element of `it` is passed to `f` alongside `first`.\n\t\tThe result of that call is then passed to `f` with the next element of\n\t\t`it`, and so on until `it` has no more elements.\n\n\t\tIf `it` or `f` are null, the result is unspecified.\n\t**/\n\tpublic static function fold<A,B>( it : Iterable<A>, f : A -> B -> B, first : B ) : B {\n\t\tfor( x in it )\n\t\t\tfirst = f(x,first);\n\t\treturn first;\n\t}\n\n\t/**\n\t\tReturns the number of elements in `it` for which `pred` is true, or the\n\t\ttotal number of elements in `it` if `pred` is null.\n\n\t\tThis function traverses all elements.\n\t**/\n\tpublic static function count<A>( it : Iterable<A>, ?pred : A -> Bool ) {\n\t\tvar n = 0;\n\t\tif( pred == null )\n\t\t\tfor( _ in it )\n\t\t\t\tn++;\n\t\telse\n\t\t\tfor( x in it )\n\t\t\t\tif( pred(x) )\n\t\t\t\t\tn++;\n\t\treturn n;\n\t}\n\n\t/**\n\t\tTells if Iterable `it` does not contain any element.\n\t**/\n\tpublic static function empty<T>( it : Iterable<T> ) : Bool {\n\t\treturn !it.iterator().hasNext();\n\t}\n\n\t/**\n\t\tReturns the index of the first element `v` within Iterable `it`.\n\n\t\tThis function uses operator `==` to check for equality.\n\n\t\tIf `v` does not exist in `it`, the result is -1.\n\t**/\n\tpublic static function indexOf<T>( it : Iterable<T>, v : T ) : Int {\n\t\tvar i = 0;\n\t\tfor( v2 in it ) {\n\t\t\tif( v == v2 )\n\t\t\t\treturn i;\n\t\t\ti++;\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t\tReturns the first element of `it` for which `f` is true.\n\n\t\tThis function returns as soon as an element is found for which a call to\n\t\t`f` returns true.\n\n\t\tIf no such element is found, the result is null.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function find<T>( it : Iterable<T>, f : T -> Bool ) : Null<T> {\n\t\tfor( v in it ) {\n\t\t\tif(f(v)) return v;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t\tReturns a new List containing all elements of Iterable `a` followed by\n\t\tall elements of Iterable `b`.\n\n\t\tIf `a` or `b` are null, the result is unspecified.\n\t**/\n\tpublic static function concat<T>( a : Iterable<T>, b : Iterable<T> ) : List<T> {\n\t\tvar l = new List();\n\t\tfor( x in a )\n\t\t\tl.add(x);\n\t\tfor( x in b )\n\t\t\tl.add(x);\n\t\treturn l;\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n\tA linked-list of elements. The list is composed of two-elements arrays\n\tthat are chained together. It is optimized so that adding or removing an\n\telement does not imply copying the whole array content every time.\n**/\nclass List<T> {\n\n\tprivate var h : Array<Dynamic>;\n\tprivate var q : Array<Dynamic>;\n\n\t/**\n\t\tThe length of `this` List.\n\t**/\n\tpublic var length(default,null) : Int;\n\n\t/**\n\t\tCreates a new empty list.\n\t**/\n\tpublic function new() {\n\t\tlength = 0;\n\t}\n\n\t/**\n\t\tAdds element `item` at the end of `this` List.\n\n\t\t`this.length` increases by 1.\n\t**/\n\tpublic function add( item : T ) {\n\t\tvar x:Array<Dynamic> = #if neko untyped __dollar__array(item,null) #else [item] #end;\n\t\tif( h == null )\n\t\t\th = x;\n\t\telse\n\t\t\tq[1] = x;\n\t\tq = x;\n\t\tlength++;\n\t}\n\n\t/**\n\t\tAdds element `item` at the beginning of `this` List.\n\n\t\t`this.length` increases by 1.\n\t**/\n\tpublic function push( item : T ) {\n\t\tvar x : Array<Dynamic> = #if neko\n\t\t\tuntyped __dollar__array(item,h)\n\t\t#else\n\t\t\t[item,h]\n\t\t#end;\n\t\th = x;\n\t\tif( q == null )\n\t\t\tq = x;\n\t\tlength++;\n\t}\n\n\t/**\n\t\tReturns the first element of `this` List, or null if no elements exist.\n\n\t\tThis function does not modify `this` List.\n\t**/\n\tpublic function first() : Null<T> {\n\t\treturn if( h == null ) null else h[0];\n\t}\n\n\t/**\n\t\tReturns the last element of `this` List, or null if no elements exist.\n\n\t\tThis function does not modify `this` List.\n\t**/\n\tpublic function last() : Null<T> {\n\t\treturn if( q == null ) null else q[0];\n\t}\n\n\n\t/**\n\t\tReturns the first element of `this` List, or null if no elements exist.\n\n\t\tThe element is removed from `this` List.\n\t**/\n\tpublic function pop() : Null<T> {\n\t\tif( h == null )\n\t\t\treturn null;\n\t\tvar x = h[0];\n\t\th = h[1];\n\t\tif( h == null )\n\t\t\tq = null;\n\t\tlength--;\n\t\treturn x;\n\t}\n\n\t/**\n\t\tTells if `this` List is empty.\n\t**/\n\tpublic function isEmpty() : Bool {\n\t\treturn (h == null);\n\t}\n\n\t/**\n\t\tEmpties `this` List.\n\n\t\tThis function does not traverse the elements, but simply sets the\n\t\tinternal references to null and `this.length` to 0.\n\t**/\n\tpublic function clear() : Void {\n\t\th = null;\n\t\tq = null;\n\t\tlength = 0;\n\t}\n\n\t/**\n\t\tRemoves the first occurence of `v` in `this` List.\n\n\t\tIf `v` is found by checking standard equality, it is removed from `this`\n\t\tList and the function returns true.\n\n\t\tOtherwise, false is returned.\n\t**/\n\tpublic function remove( v : T ) : Bool {\n\t\tvar prev = null;\n\t\tvar l = h;\n\t\twhile( l != null ) {\n\t\t\tif( l[0] == v ) {\n\t\t\t\tif( prev == null )\n\t\t\t\t\th = l[1];\n\t\t\t\telse\n\t\t\t\t\tprev[1] = l[1];\n\t\t\t\tif( q == l )\n\t\t\t\t\tq = prev;\n\t\t\t\tlength--;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tprev = l;\n\t\t\tl = l[1];\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t\tReturns an iterator on the elements of the list.\n\t**/\n\tpublic function iterator() : Iterator<T> {\n\t\t#if (java || cs)\n\t\tvar h = h;\n\t\treturn cast {\n\t\t\thasNext : function() {\n\t\t\t\treturn (h != null);\n\t\t\t},\n\t\t\tnext : function() {\n\t\t\t\t{\n\t\t\t\t\tif( h == null )\n\t\t\t\t\t\treturn null;\n\t\t\t\t\tvar x = h[0];\n\t\t\t\t\th = h[1];\n\t\t\t\t\treturn x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t#else\n\t\treturn cast {\n\t\t\th : h,\n\t\t\thasNext : function() {\n\t\t\t\treturn untyped (__this__.h != null);\n\t\t\t},\n\t\t\tnext : function() {\n\t\t\t\tuntyped {\n\t\t\t\t\tif( __this__.h == null )\n\t\t\t\t\t\treturn null;\n\t\t\t\t\tvar x = __this__.h[0];\n\t\t\t\t\t__this__.h = __this__.h[1];\n\t\t\t\t\treturn x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t#end\n\t}\n\n\t/**\n\t\tReturns a string representation of `this` List.\n\n\t\tThe result is enclosed in { } with the individual elements being\n\t\tseparated by a comma.\n\t**/\n\tpublic function toString() {\n\t\tvar s = new StringBuf();\n\t\tvar first = true;\n\t\tvar l = h;\n\t\ts.add(\"{\");\n\t\twhile( l != null ) {\n\t\t\tif( first )\n\t\t\t\tfirst = false;\n\t\t\telse\n\t\t\t\ts.add(\", \");\n\t\t\ts.add(Std.string(l[0]));\n\t\t\tl = l[1];\n\t\t}\n\t\ts.add(\"}\");\n\t\treturn s.toString();\n\t}\n\n\t/**\n\t\tReturns a string representation of `this` List, with `sep` separating\n\t\teach element.\n\t**/\n\tpublic function join(sep : String) {\n\t\tvar s = new StringBuf();\n\t\tvar first = true;\n\t\tvar l = h;\n\t\twhile( l != null ) {\n\t\t\tif( first )\n\t\t\t\tfirst = false;\n\t\t\telse\n\t\t\t\ts.add(sep);\n\t\t\ts.add(l[0]);\n\t\t\tl = l[1];\n\t\t}\n\t\treturn s.toString();\n\t}\n\n\t/**\n\t\tReturns a list filtered with `f`. The returned list will contain all\n\t\telements for which `f(x) == true`.\n\t**/\n\tpublic function filter( f : T -> Bool ) {\n\t\tvar l2 = new List();\n\t\tvar l = h;\n\t\twhile( l != null ) {\n\t\t\tvar v = l[0];\n\t\t\tl = l[1];\n\t\t\tif( f(v) )\n\t\t\t\tl2.add(v);\n\t\t}\n\t\treturn l2;\n\t}\n\n\t/**\n\t\tReturns a new list where all elements have been converted by the\n\t\tfunction `f`.\n\t**/\n\tpublic function map<X>(f : T -> X) : List<X> {\n\t\tvar b = new List();\n\t\tvar l = h;\n\t\twhile( l != null ) {\n\t\t\tvar v = l[0];\n\t\t\tl = l[1];\n\t\t\tb.add(f(v));\n\t\t}\n\t\treturn b;\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\nimport js.Boot;\n\n@:keepInit\n@:coreApi class Std {\n\n\tpublic static inline function is( v : Dynamic, t : Dynamic ) : Bool {\n\t\treturn untyped js.Boot.__instanceof(v,t);\n\t}\n\n\tpublic static inline function instance<T:{},S:T>( value : T, c : Class<S> ) : S {\n\t\treturn untyped __instanceof__(value, c) ? cast value : null;\n\t}\n\n\tpublic static function string( s : Dynamic ) : String {\n\t\treturn untyped js.Boot.__string_rec(s,\"\");\n\t}\n\n\tpublic static inline function int( x : Float ) : Int {\n\t\treturn cast(x) | 0;\n\t}\n\n\tpublic static function parseInt( x : String ) : Null<Int> {\n\t\tvar v = untyped __js__(\"parseInt\")(x, 10);\n\t\t// parse again if hexadecimal\n\t\tif( v == 0 && (x.charCodeAt(1) == 'x'.code || x.charCodeAt(1) == 'X'.code) )\n\t\t\tv = untyped __js__(\"parseInt\")(x);\n\t\tif( untyped __js__(\"isNaN\")(v) )\n\t\t\treturn null;\n\t\treturn cast v;\n\t}\n\n\tpublic static function parseFloat( x : String ) : Float {\n\t\treturn untyped __js__(\"parseFloat\")(x);\n\t}\n\n\tpublic static function random( x : Int ) : Int {\n\t\treturn untyped x <= 0 ? 0 : Math.floor(Math.random()*x);\n\t}\n\n\tstatic function __init__() : Void untyped {\n\t\t__feature__(\"js.Boot.getClass\",String.prototype.__class__ = __feature__(\"Type.resolveClass\",$hxClasses[\"String\"] = String,String));\n\t\t__feature__(\"js.Boot.isClass\",String.__name__ = __feature__(\"Type.getClassName\",[\"String\"],true));\n\t\t__feature__(\"Type.resolveClass\",$hxClasses[\"Array\"] = Array);\n\t\t__feature__(\"js.Boot.isClass\",Array.__name__ = __feature__(\"Type.getClassName\",[\"Array\"],true));\n\t\t__feature__(\"Date.*\", {\n\t\t\t__feature__(\"js.Boot.getClass\",__js__('Date').prototype.__class__ = __feature__(\"Type.resolveClass\",$hxClasses[\"Date\"] = __js__('Date'),__js__('Date')));\n\t\t\t__feature__(\"js.Boot.isClass\",__js__('Date').__name__ = [\"Date\"]);\n\t\t});\n\t\t__feature__(\"Int.*\",{\n\t\t\tvar Int = __feature__(\"Type.resolveClass\", $hxClasses[\"Int\"] = { __name__ : [\"Int\"] }, { __name__ : [\"Int\"] });\n\t\t});\n\t\t__feature__(\"Dynamic.*\",{\n\t\t\tvar Dynamic = __feature__(\"Type.resolveClass\", $hxClasses[\"Dynamic\"] = { __name__ : [\"Dynamic\"] }, { __name__ : [\"Dynamic\"] });\n\t\t});\n\t\t__feature__(\"Float.*\",{\n\t\t\tvar Float = __feature__(\"Type.resolveClass\", $hxClasses[\"Float\"] = __js__(\"Number\"), __js__(\"Number\"));\n\t\t\tFloat.__name__ = [\"Float\"];\n\t\t});\n\t\t__feature__(\"Bool.*\",{\n\t\t\tvar Bool = __feature__(\"Type.resolveEnum\",$hxClasses[\"Bool\"] = __js__(\"Boolean\"), __js__(\"Boolean\"));\n\t\t\tBool.__ename__ = [\"Bool\"];\n\t\t});\n\t\t__feature__(\"Class.*\",{\n\t\t\tvar Class = __feature__(\"Type.resolveClass\", $hxClasses[\"Class\"] = { __name__ : [\"Class\"] }, { __name__ : [\"Class\"] });\n\t\t});\n\t\t__feature__(\"Enum.*\",{\n\t\t\tvar Enum = {};\n\t\t});\n\t\t__feature__(\"Void.*\",{\n\t\t\tvar Void = __feature__(\"Type.resolveEnum\", $hxClasses[\"Void\"] = { __ename__ : [\"Void\"] }, { __ename__ : [\"Void\"] });\n\t\t});\n\n#if !js_es5\n\t\t__feature__(\"Array.map\",\n\t\t\tif( Array.prototype.map == null )\n\t\t\t\tArray.prototype.map = function(f) {\n\t\t\t\t\tvar a = [];\n\t\t\t\t\tfor( i in 0...__this__.length )\n\t\t\t\t\t\ta[i] = f(__this__[i]);\n\t\t\t\t\treturn a;\n\t\t\t\t}\n\t\t);\n\t\t__feature__(\"Array.filter\",\n\t\t\tif( Array.prototype.filter == null )\n\t\t\t\tArray.prototype.filter = function(f) {\n\t\t\t\t\tvar a = [];\n\t\t\t\t\tfor( i in 0...__this__.length ) {\n\t\t\t\t\t\tvar e = __this__[i];\n\t\t\t\t\t\tif( f(e) ) a.push(e);\n\t\t\t\t\t}\n\t\t\t\t\treturn a;\n\t\t\t\t}\n\t\t);\n#end\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n\tA String buffer is an efficient way to build a big string by appending small\n\telements together.\n\n\tIts cross-platform implementation uses String concatenation internally, but\n\tStringBuf may be optimized for different targets.\n\n\tUnlike String, an instance of StringBuf is not immutable in the sense that\n\tit can be passed as argument to functions which modify it by appending more\n\tvalues. However, the internal buffer cannot be modified.\n**/\nclass StringBuf {\n\n\tvar b:String = \"\";\n\n\t/**\n\t\tThe length of `this` StringBuf in characters.\n\t**/\n\tpublic var length(get,never) : Int;\n\n\t/**\n\t\tCreates a new StringBuf instance.\n\n\t\tThis may involve initialization of the internal buffer.\n\t**/\n\tpublic function new() {}\n\n\tinline function get_length() : Int {\n\t\treturn b.length;\n\t}\n\n\t/**\n\t\tAppends the representation of `x` to `this` StringBuf.\n\n\t\tThe exact representation of `x` may vary per platform. To get more\n\t\tconsistent behavior, this function should be called with\n\t\tStd.string(x).\n\n\t\tIf `x` is null, the String \"null\" is appended.\n\t**/\n\tpublic inline function add<T>( x : T ) : Void {\n\t\tb += x;\n\t}\n\n\t/**\n\t\tAppends the character identified by `c` to `this` StringBuf.\n\n\t\tIf `c` is negative or has another invalid value, the result is\n\t\tunspecified.\n\t**/\n\tpublic inline function addChar( c : Int ) : Void {\n\t\tb += String.fromCharCode(c);\n\t}\n\n\t/**\n\t\tAppends a substring of `s` to `this` StringBuf.\n\n\t\tThis function expects `pos` and `len` to describe a valid substring of\n\t\t`s`, or else the result is unspecified. To get more robust behavior,\n\t\t`this.add(s.substr(pos,len))` can be used instead.\n\n\t\tIf `s` or `pos` are null, the result is unspecified.\n\n\t\tIf `len` is omitted or null, the substring ranges from `pos` to the end\n\t\tof `s`.\n\t**/\n\tpublic inline function addSub( s : String, pos : Int, ?len : Int) : Void {\n\t\tb += (len == null ? s.substr(pos) : s.substr(pos, len));\n\t}\n\n\t/**\n\t\tReturns the content of `this` StringBuf as String.\n\n\t\tThe buffer is not emptied by this operation.\n\t**/\n\tpublic inline function toString() : String {\n\t\treturn b;\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n\tThis class provides advanced methods on Strings. It is ideally used with\n\t'using StringTools' and then acts as an extension to the String class.\n\n\tIf the first argument to any of the methods is null, the result is\n\tunspecified.\n**/\n#if cs\n@:keep\n#end\nclass StringTools {\n\t/**\n\t\tEncode an URL by using the standard format.\n\t**/\n\t#if (!java && !cpp) inline #end public static function urlEncode( s : String ) : String untyped {\n\t\t#if flash9\n\t\t\treturn __global__[\"encodeURIComponent\"](s);\n\t\t#elseif flash\n\t\t\treturn _global[\"escape\"](s);\n\t\t#elseif neko\n\t\t\treturn new String(_urlEncode(s.__s));\n\t\t#elseif js\n\t\t\treturn encodeURIComponent(s);\n\t\t#elseif cpp\n\t\t\treturn s.__URLEncode();\n\t\t#elseif java\n\t\t\ttry\n\t\t\t\treturn untyped __java__(\"java.net.URLEncoder.encode(s, \\\"UTF-8\\\")\")\n\t\t\tcatch (e:Dynamic) throw e;\n\t\t#elseif cs\n\t\t\treturn cs.system.Uri.EscapeUriString(s);\n\t\t#else\n\t\t\treturn null;\n\t\t#end\n\t}\n\n\t/**\n\t\tDecode an URL using the standard format.\n\t**/\n\t#if (!java && !cpp) inline #end public static function urlDecode( s : String ) : String untyped {\n\t\t#if flash9\n\t\t\treturn __global__[\"decodeURIComponent\"](s.split(\"+\").join(\" \"));\n\t\t#elseif flash\n\t\t\treturn _global[\"unescape\"](s);\n\t\t#elseif neko\n\t\t\treturn new String(_urlDecode(s.__s));\n\t\t#elseif js\n\t\t\treturn decodeURIComponent(s.split(\"+\").join(\" \"));\n\t\t#elseif cpp\n\t\t\treturn s.__URLDecode();\n\t\t#elseif java\n\t\t\ttry\n\t\t\t\treturn untyped __java__(\"java.net.URLDecoder.decode(s, \\\"UTF-8\\\")\")\n\t\t\tcatch (e:Dynamic) throw e;\n\t\t#elseif cs\n\t\t\treturn cs.system.Uri.UnescapeDataString(s);\n\t\t#else\n\t\t\treturn null;\n\t\t#end\n\t}\n\n\t/**\n\t\tEscapes HTML special characters of the string `s`.\n\n\t\tThe following replacements are made:\n\n\t\t- `&` becomes `&amp`;\n\t\t- `<` becomes `&lt`;\n\t\t- `>` becomes `&gt`;\n\n\t\tIf `quotes` is true, the following characters are also replaced:\n\n\t\t- `\"` becomes `&quot`;\n\t\t- `'` becomes `&#039`;\n\t**/\n\tpublic static function htmlEscape( s : String, ?quotes : Bool ) : String {\n\t\ts = s.split(\"&\").join(\"&amp;\").split(\"<\").join(\"&lt;\").split(\">\").join(\"&gt;\");\n\t\treturn quotes ? s.split('\"').join(\"&quot;\").split(\"'\").join(\"&#039;\") : s;\n\t}\n\n\t/**\n\t\tUnescapes HTML special characters of the string `s`.\n\n\t\tThis is the inverse operation to htmlEscape, i.e. the following always\n\t\tholds: htmlUnescape(htmlEscape(s)) == s\n\n\t\tThe replacements follow:\n\n\t\t- `&amp;` becomes `&`\n\t\t- `&lt;` becomes `<`\n\t\t- `&gt;` becomes `>`\n\t\t- `&quot;` becomes `\"`\n\t\t- `&#039;` becomes `'`\n\t**/\n\tpublic static function htmlUnescape( s : String ) : String {\n\t\treturn s.split(\"&gt;\").join(\">\").split(\"&lt;\").join(\"<\").split(\"&quot;\").join('\"').split(\"&#039;\").join(\"'\").split(\"&amp;\").join(\"&\");\n\t}\n\n\t/**\n\t\tTells if the string `s` starts with the string `start`.\n\n\t\tIf `start` is null, the result is unspecified.\n\n\t\tIf `start` is the empty String \"\", the result is true.\n\t**/\n\tpublic static #if (cs || java) inline #end function startsWith( s : String, start : String ) : Bool {\n\t\t#if java\n\t\treturn untyped s.startsWith(start);\n\t\t#elseif cs\n\t\treturn untyped s.StartsWith(start);\n\t\t#else\n\t\treturn( s.length >= start.length && s.substr(0, start.length) == start );\n\t\t#end\n\t}\n\n\t/**\n\t\tTells if the string `s` ends with the string `end`.\n\n\t\tIf `end` is null, the result is unspecified.\n\n\t\tIf `end` is the empty String \"\", the result is true.\n\t**/\n\tpublic static #if (cs || java) inline #end function endsWith( s : String, end : String ) : Bool {\n\t\t#if java\n\t\treturn untyped s.endsWith(end);\n\t\t#elseif cs\n\t\treturn untyped s.EndsWith(end);\n\t\t#else\n\t\tvar elen = end.length;\n\t\tvar slen = s.length;\n\t\treturn( slen >= elen && s.substr(slen - elen, elen) == end );\n\t\t#end\n\t}\n\n\t/**\n\t\tTells if the character in the string `s` at position `pos` is a space.\n\n\t\tA character is considered to be a space character if its character code\n\t\tis 9,10,11,12,13 or 32.\n\n\t\tIf `s` is the empty String \"\", or if pos is not a valid position within\n\t\t`s`, the result is false.\n\t**/\n\tpublic static function isSpace( s : String, pos : Int ) : Bool {\n\t\tvar c = s.charCodeAt( pos );\n\t\treturn (c > 8 && c < 14) || c == 32;\n\t}\n\n\t/**\n\t\tRemoves leading space characters of `s`.\n\n\t\tThis function internally calls isSpace() to decide which characters to\n\t\tremove.\n\n\t\tIf `s` is the empty String \"\" or consists only of space characters, the\n\t\tresult is the empty String \"\".\n\t**/\n\tpublic #if cs inline #end static function ltrim( s : String ) : String {\n\t\t#if cs\n\t\treturn untyped s.TrimStart();\n\t\t#else\n\t\tvar l = s.length;\n\t\tvar r = 0;\n\t\twhile( r < l && isSpace(s,r) ){\n\t\t\tr++;\n\t\t}\n\t\tif( r > 0 )\n\t\t\treturn s.substr(r, l-r);\n\t\telse\n\t\t\treturn s;\n\t\t#end\n\t}\n\n\t/**\n\t\tRemoves trailing space characters of `s`.\n\n\t\tThis function internally calls isSpace() to decide which characters to\n\t\tremove.\n\n\t\tIf `s` is the empty String \"\" or consists only of space characters, the\n\t\tresult is the empty String \"\".\n\t**/\n\tpublic #if cs inline #end static function rtrim( s : String ) : String {\n\t\t#if cs\n\t\treturn untyped s.TrimEnd();\n\t\t#else\n\t\tvar l = s.length;\n\t\tvar r = 0;\n\t\twhile( r < l && isSpace(s,l-r-1) ){\n\t\t\tr++;\n\t\t}\n\t\tif( r > 0 ){\n\t\t\treturn s.substr(0, l-r);\n\t\t}else{\n\t\t\treturn s;\n\t\t}\n\t\t#end\n\t}\n\n\t/**\n\t\tRemoves leading and trailing space characters of `s`.\n\n\t\tThis is a convenience function for ltrim(rtrim(s)).\n\t**/\n\tpublic #if (cs || java) inline #end static function trim( s : String ) : String {\n\t\t#if cs\n\t\treturn untyped s.Trim();\n\t\t#elseif java\n\t\treturn untyped s.trim();\n\t\t#else\n\t\treturn ltrim(rtrim(s));\n\t\t#end\n\t}\n\n\t/**\n\t\tConcatenates `c` to `s` until `s.length` is at least `l`.\n\n\t\tIf `c` is the empty String \"\" or if `l` does not exceed `s.length`,\n\t\t`s` is returned unchanged.\n\n\t\tIf `c.length` is 1, the resulting String length is exactly `l`.\n\n\t\tOtherwise the length may exceed `l`.\n\n\t\tIf `c` is null, the result is unspecified.\n\t**/\n\tpublic static function lpad( s : String, c : String, l : Int ) : String {\n\t\tif (c.length <= 0)\n\t\t\treturn s;\n\n\t\twhile (s.length < l) {\n\t\t\ts = c + s;\n\t\t}\n\t\treturn s;\n\t}\n\n\t/**\n\t\tAppends `c` to `s` until `s.length` is at least `l`.\n\n\t\tIf `c` is the empty String \"\" or if `l` does not exceed `s.length`,\n\t\t`s` is returned unchanged.\n\n\t\tIf `c.length` is 1, the resulting String length is exactly `l`.\n\n\t\tOtherwise the length may exceed `l`.\n\n\t\tIf `c` is null, the result is unspecified.\n\t**/\n\tpublic static function rpad( s : String, c : String, l : Int ) : String {\n\t\tif (c.length <= 0)\n\t\t\treturn s;\n\n\t\twhile (s.length < l) {\n\t\t\ts = s + c;\n\t\t}\n\t\treturn s;\n\t}\n\n\t/**\n\t\tReplace all occurences of the String `sub` in the String `s` by the\n\t\tString `by`.\n\n\t\tIf `sub` is the empty String \"\", `by` is inserted after each character\n\t\tof `s`. If `by` is also the empty String \"\", `s` remains unchanged.\n\n\t\tThis is a convenience function for `s.split(sub).join(by)`.\n\n\t\tIf `sub` or `by` are null, the result is unspecified.\n\t**/\n\tpublic static function replace( s : String, sub : String, by : String ) : String {\n\t\t#if java\n\t\tif (sub.length == 0)\n\t\t\treturn s.split(sub).join(by);\n\t\telse\n\t\t\treturn untyped s.replace(sub, by);\n\t\t#elseif cs\n\t\tif (sub.length == 0)\n\t\t\treturn s.split(sub).join(by);\n\t\telse\n\t\t\treturn untyped s.Replace(sub, by);\n\t\t#else\n\t\treturn s.split(sub).join(by);\n\t\t#end\n\t}\n\n\t/**\n\t\tEncodes `n` into a hexadecimal representation.\n\n\t\tIf `digits` is specified, the resulting String is padded with \"0\" until\n\t\tits length equals `digits`.\n\t**/\n\tpublic static function hex( n : Int, ?digits : Int ) {\n\t\t#if flash9\n\t\t\tvar n : UInt = n;\n\t\t\tvar s : String = untyped n.toString(16);\n\t\t\ts = s.toUpperCase();\n\t\t#else\n\t\t\tvar s = \"\";\n\t\t\tvar hexChars = \"0123456789ABCDEF\";\n\t\t\tdo {\n\t\t\t\ts = hexChars.charAt(n&15) + s;\n\t\t\t\tn >>>= 4;\n\t\t\t} while( n > 0 );\n\t\t#end\n\t\tif( digits != null )\n\t\t\twhile( s.length < digits )\n\t\t\t\ts = \"0\"+s;\n\t\treturn s;\n\t}\n\n\t/**\n\t\tReturns the character code at position `index` of String `s`.\n\n\t\tThis method is faster than String.charCodeAt() on most platforms.\n\t\tHowever, unlike String.charCodeAt(), the result is unspecified if\n\t\t`index` is negative or exceeds `s.length`.\n\n\t\tThis operation is not guaranteed to work if `s` contains the \\0\n\t\tcharacter.\n\t**/\n\tpublic static inline function fastCodeAt( s : String, index : Int ) : Int untyped {\n\t\t#if neko\n\t\treturn untyped __dollar__sget(s.__s, index);\n\t\t#elseif cpp\n\t\treturn s.cca(index);\n\t\t#elseif flash9\n\t\treturn s.cca(index);\n\t\t#elseif flash\n\t\treturn s[\"cca\"](index);\n\t\t#elseif java\n\t\treturn ( index < s.length ) ? cast(_charAt(s, index), Int) : -1;\n\t\t#elseif cs\n\t\treturn ( cast(index, UInt) < s.length ) ? cast(untyped s[index], Int) : -1;\n\t\t#elseif js\n\t\t\t#if mt\n\t\treturn (untyped s).cca(index);\n\t\t\t#else\n\t\treturn (untyped s).charCodeAt(index);\n\t\t\t#end\n\t\t#else\n\t\treturn s.cca(index);\n\t\t#end\n\t}\n\n\t/*\n\t\tTells if `c` represents the end-of-file (EOF) character.\n\t*/\n\t@:noUsing public static inline function isEof( c : Int ) : Bool {\n\t\t#if (flash9 || cpp)\n\t\treturn c == 0;\n\t\t#elseif flash8\n\t\treturn c <= 0; // fast NaN\n\t\t#elseif js\n\t\treturn c != c; // fast NaN\n\t\t#elseif neko\n\t\treturn c == null;\n\t\t#elseif cs\n\t\treturn c == -1;\n\t\t#elseif java\n\t\treturn c == -1;\n\t\t#else\n\t\treturn false;\n\t\t#end\n\t}\n\n\t#if java\n\tprivate static inline function _charAt(str:String, idx:Int):java.StdTypes.Char16 return untyped str._charAt(idx);\n\t#end\n\n\t#if neko\n\tprivate static var _urlEncode = neko.Lib.load(\"std\",\"url_encode\",1);\n\tprivate static var _urlDecode = neko.Lib.load(\"std\",\"url_decode\",1);\n\t#end\n\n}\n","package buddy ;\r\nimport buddy.BuddySuite.Spec;\r\nimport buddy.BuddySuite.Suite;\r\nimport buddy.reporting.Reporter;\r\nimport haxe.CallStack;\r\nimport promhx.Deferred;\r\nimport promhx.Promise;\r\nimport buddy.Should;\r\nusing buddy.tools.AsyncTools;\r\n\r\nprivate typedef Action = (Void -> Void) -> SpecAssertion -> Void;\r\n\r\nenum TestStatus\r\n{\r\n\tUnknown;\r\n\tPassed;\r\n\tPending;\r\n\tFailed;\r\n}\r\n\r\nclass BeforeAfter\r\n{\r\n\tpublic var async(default, null) : Bool;\r\n\t@:allow(buddy.internal.SuiteRunner) private var run : Action;\r\n\r\n\tpublic function new(run : Action, async = false)\r\n\t{\r\n\t\tthis.run = run;\r\n\t\tthis.async = async;\r\n\t}\r\n}\r\n\r\nclass Suite\r\n{\r\n\tpublic var name(default, null) : String;\r\n\tpublic var buddySuite(default, null) : BuddySuite;\r\n\t@:allow(buddy.BuddySuite) public var include(default, null) : Bool;\r\n\t@:allow(buddy.BuddySuite) public var specs(default, null) : Array<Spec>;\r\n\r\n\t@:allow(buddy.internal.SuiteRunner) @:allow(buddy.BuddySuite) private var before : List<BeforeAfter>;\r\n\t@:allow(buddy.internal.SuiteRunner) @:allow(buddy.BuddySuite) private var after : List<BeforeAfter>;\r\n\r\n\tpublic function new(name : String, buddySuite : BuddySuite)\r\n\t{\r\n\t\tif (name == null) throw \"Suite requires a name.\";\r\n\t\tif (buddySuite == null) throw \"Suite requires a BuddySuite.\";\r\n\r\n\t\tthis.name = name;\r\n\t\tthis.buddySuite = buddySuite;\r\n\r\n\t\tthis.specs = new Array<Spec>();\r\n\t\tthis.before = new List<BeforeAfter>();\r\n\t\tthis.after = new List<BeforeAfter>();\r\n\t}\r\n}\r\n\r\nclass Spec\r\n{\r\n\tpublic var suite(default, null) : Suite;\r\n\tpublic var description(default, null) : String;\r\n\tpublic var async(default, null) : Bool;\r\n\tpublic var status(default, null) : TestStatus;\r\n\tpublic var error(default, null) : String;\r\n\t@:allow(buddy.internal.SuiteRunner) public var stack(default, null) : Null<Array<StackItem>>;\r\n\t@:allow(buddy.internal.SuiteRunner) public var traces(default, null) : List<String>;\r\n\t@:allow(buddy.BuddySuite) public var include(default, null) : Bool;\r\n\r\n\t@:allow(buddy.internal.SuiteRunner) private var run : Action;\r\n\r\n\t@:allow(buddy.internal.SuiteRunner) private function setStatus(s : TestStatus, err : String, stack : Array<StackItem>)\r\n\t{\r\n\t\tthis.status = s;\r\n\t\tthis.error = err;\r\n\t\tthis.stack = stack;\r\n\t}\r\n\r\n\tpublic function new(suite : Suite, description : String, run : Action, async = false, pending = false)\r\n\t{\r\n\t\tthis.suite = suite;\r\n\t\tthis.description = description;\r\n\t\tthis.run = run;\r\n\t\tthis.async = async;\r\n\t\tthis.traces = new List<String>();\r\n\r\n\t\tif (run == null) this.status = TestStatus.Pending;\r\n\t\telse this.status = pending ? TestStatus.Pending : TestStatus.Unknown;\r\n\t}\r\n}\r\n\r\n@:autoBuild(buddy.internal.SuiteBuilder.build())\r\nclass BuddySuite\r\n{\r\n\tpublic var suites(default, null) : List<Suite>;\r\n\r\n\t@:allow(buddy.internal.SuiteRunner) @:allow(buddy.BuddySuite) private var befores : List<BeforeAfter>;\r\n\t@:allow(buddy.internal.SuiteRunner) @:allow(buddy.BuddySuite) private var afters : List<BeforeAfter>;\r\n\r\n\t// If set, suites are only included if marked by @include or if one of its specs are marked with @include\r\n\tpublic static var includeMode : Bool;\r\n\r\n\tpublic static var exclude(default, never) : String = \"exclude\";\r\n\tpublic static var include(default, never) : String = \"include\";\r\n\r\n\t/**\r\n\t * Milliseconds before an async spec timeout with an error. Default is 5000 (5 sec).\r\n\t */\r\n\tpublic var timeoutMs(default, default) : Int;\r\n\r\n\tpublic function new()\r\n\t{\r\n\t\tthis.suites = new List<Suite>();\r\n\t\tthis.befores = new List<BeforeAfter>();\r\n\t\tthis.afters = new List<BeforeAfter>();\r\n\r\n\t\tthis.timeoutMs = 5000;\r\n\t}\r\n\r\n\t///// Private API /////\r\n\r\n\tprivate function describe(name : String, addSpecs : Void -> Void)\r\n\t{\r\n\t\taddSuite(new Suite(name, this), addSpecs);\r\n\t}\r\n\r\n\tprivate function xdescribe(name : String, addSpecs : Void -> Void)\r\n\t{}\r\n\r\n\tprivate function before(init : Action)\r\n\t{\r\n\t\tsyncBefore(init, true);\r\n\t}\r\n\r\n\tprivate function after(deinit : Action)\r\n\t{\r\n\t\tsyncAfter(deinit, true);\r\n\t}\r\n\r\n\tprivate function it(desc : String, test : Action = null)\r\n\t{\r\n\t\tsyncIt(desc, test, true);\r\n\t}\r\n\r\n\tprivate function xit(desc : String, test : Action = null)\r\n\t{\r\n\t\tsyncXit(desc, test, true);\r\n\t}\r\n\r\n\t///// Hidden \"include\" handlers /////\r\n\r\n\t@:noCompletion private function addSuite(suite : Suite, addSpecs : Void -> Void)\r\n\t{\r\n\t\tsuites.add(suite);\r\n\t\taddSpecs();\r\n\r\n\t\tif (!includeMode) return;\r\n\r\n\t\tif (!suite.include)\r\n\t\t{\r\n\t\t\t// If current suite has specs marked with @include, add them only.\r\n\t\t\tsuite.specs = suite.specs.filter(function(sp) return sp.include);\r\n\t\t\tif (suite.specs.length > 0) suite.include = true;\r\n\t\t}\r\n\r\n\t\tsuites = suites.filter(function(s) return s.include);\r\n\t}\r\n\r\n\t@:noCompletion private function describeInclude(name : String, addSpecs : Void -> Void)\r\n\t{\r\n\t\tincludeMode = true;\r\n\t\tvar suite = new Suite(name, this);\r\n\t\tsuite.include = true;\r\n\r\n\t\taddSuite(suite, addSpecs);\r\n\t}\r\n\r\n\t@:noCompletion private function itInclude(desc : String, test : Action = null)\r\n\t{\r\n\t\tincludeMode = true;\r\n\t\tsyncIt(desc, test, true, true);\r\n\t}\r\n\r\n\t@:noCompletion private function syncItInclude(desc : String, test : Action = null)\r\n\t{\r\n\t\tincludeMode = true;\r\n\t\tsyncIt(desc, test, false, true);\r\n\t}\r\n\r\n\t@:noCompletion private function beforeDescribe(init : Action)\r\n\t{\r\n\t\tsyncBeforeDescribe(init, true);\r\n\t}\r\n\r\n\t@:noCompletion private function afterDescribe(init : Action)\r\n\t{\r\n\t\tsyncAfterDescribe(init, true);\r\n\t}\r\n\r\n\t///// Hidden syncronous handlers /////\r\n\r\n\t@:noCompletion private function syncBeforeDescribe(init : Action, async = false)\r\n\t{\r\n\t\tbefores.add(new BeforeAfter(init, async));\r\n\t}\r\n\r\n\t@:noCompletion private function syncAfterDescribe(init : Action, async = false)\r\n\t{\r\n\t\tafters.add(new BeforeAfter(init, async));\r\n\t}\r\n\r\n\t@:noCompletion private function syncBefore(init : Action, async = false)\r\n\t{\r\n\t\tsuites.last().before.add(new BeforeAfter(init, async));\r\n\t}\r\n\r\n\t@:noCompletion private function syncAfter(deinit : Action, async = false)\r\n\t{\r\n\t\tsuites.last().after.add(new BeforeAfter(deinit, async));\r\n\t}\r\n\r\n\t@:noCompletion private function syncIt(desc : String, test : Action, async = false, include = false)\r\n\t{\r\n\t\tvar suite = suites.last();\r\n\t\tvar spec = new Spec(suite, desc, test, async);\r\n\r\n\t\tspec.include = include;\r\n\t\tsuite.specs.push(spec);\r\n\t}\r\n\r\n\t@:noCompletion private function syncXit(desc : String, test : Action, async = false)\r\n\t{\r\n\t\tvar suite = suites.last();\r\n\t\tvar spec = new Spec(suite, desc, test, async, true);\r\n\r\n\t\tsuite.specs.push(spec);\r\n\t}\r\n}\r\n\r\n","package ;\nimport js.node.Fs;\n\nimport buddy.*;\nusing buddy.Should;\n\n/**\n * @author AS3Boyan\n * null\n * null\n */\n\n@:build(buddy.GenerateMain.build([\"pack1\",\"pack2.subpack\"]))\nclass TestMain extends BuddySuite\n{\n\tpublic function new() \n\t{\n\t\t// A test suite:\n        describe(\"Using Buddy\", {\n            var experience = \"?\";\n            var mood = \"?\";\n\n            // Executed before each \"it\":\n            before({\n                experience = \"great\";\n            });\n\n            it(\"should be a great testing experience\", {\n                experience.should.be(\"great\");\n            });\n\n            it(\"should really make the tester happy\", {\n                mood.should.be(\"happy\");\n            });\n\n            // Executed after each \"it\":\n            after({\n                mood = \"happy\";\n            });\n        });\n\t}\n}","package buddy.internal ;\r\n#if macro\r\nimport haxe.macro.Compiler;\r\nimport haxe.macro.Expr;\r\nimport haxe.macro.ExprTools;\r\nimport haxe.macro.Type;\r\nimport haxe.macro.Context;\r\nusing haxe.macro.ExprTools;\r\n\r\nclass SuiteBuilder\r\n{\r\n\tprivate static function debugDisplay(e : Expr)\r\n\t{\r\n\t\tvar file = sys.io.File.write(\"e:\\\\temp\\\\buddy.txt\", false);\r\n\t\tfile.writeString(Std.string(e.expr));\r\n\t\tfile.writeString(\"\\r\\n\\r\\n\" + e.toString());\r\n\t\tfile.close();\r\n\t}\r\n\r\n\tprivate static function injectAsync(e : Expr)\r\n\t{\r\n\t\tswitch(e.expr)\r\n\t\t{\r\n\t\t\t// Fix autocomplete for should without parenthesis\r\n\t\t\tcase EDisplay(e2, isCall):\r\n\r\n\t\t\t\tswitch(e2)\r\n\t\t\t\t{\r\n\t\t\t\t\tcase macro $a.should:\r\n\t\t\t\t\t\tvar change = macro $a.should();\r\n\t\t\t\t\t\te2.expr = change.expr;\r\n\r\n\t\t\t\t\tcase _:\r\n\t\t\t\t}\r\n\r\n\t\t\tcase _:\r\n\t\t}\r\n\r\n\t\tswitch(e)\r\n\t\t{\r\n\t\t\tcase macro $a.should().$b, macro $a.should.$b:\r\n\t\t\t\t// Need to use untyped here for some unknown macro reason...\r\n\t\t\t\tvar change = macro $a.should(untyped __status).$b;\r\n\t\t\t\te.expr = change.expr;\r\n\r\n\t\t\t/////\r\n\r\n\t\t\tcase macro @include describe($s, function() $f), macro @include describe($s, $f):\r\n\t\t\t\tvar change = macro describeInclude($s, function() $f);\r\n\t\t\t\te.expr = change.expr;\r\n\t\t\t\tf.iter(injectAsync);\r\n\r\n\t\t\tcase macro describe($s, function() $f), macro describe($s, $f):\r\n\t\t\t\tvar change = macro describe($s, function() $f);\r\n\t\t\t\te.expr = change.expr;\r\n\t\t\t\tf.iter(injectAsync);\r\n\r\n\t\t\tcase macro xdescribe($s, function() $f), macro xdescribe($s, $f), macro @exclude describe($s, function() $f), macro @exclude describe($s, $f):\r\n\t\t\t\tvar change = macro xdescribe($s, function() $f);\r\n\t\t\t\te.expr = change.expr;\r\n\t\t\t\tf.iter(injectAsync);\r\n\r\n\t\t\t/////\r\n\r\n\t\t\tcase macro before(function($n) $f):\r\n\t\t\t\tvar change = macro before(function($n, __status) $f);\r\n\t\t\t\te.expr = change.expr;\r\n\t\t\t\tf.iter(injectAsync);\r\n\r\n\t\t\tcase macro before(function() $f), macro before($f):\r\n\t\t\t\tvar change = macro syncBefore(function(__asyncDone, __status) $f);\r\n\t\t\t\te.expr = change.expr;\r\n\t\t\t\tf.iter(injectAsync);\r\n\r\n\t\t\t/////\r\n\r\n\t\t\tcase macro after(function($n) $f):\r\n\t\t\t\tvar change = macro after(function($n, __status) $f);\r\n\t\t\t\te.expr = change.expr;\r\n\t\t\t\tf.iter(injectAsync);\r\n\r\n\t\t\tcase macro after(function() $f), macro after($f):\r\n\t\t\t\tvar change = macro syncAfter(function(__asyncDone, __status) $f);\r\n\t\t\t\te.expr = change.expr;\r\n\t\t\t\tf.iter(injectAsync);\r\n\r\n\t\t\t/////\r\n\r\n\t\t\tcase macro @include it($s, function($n) $f):\r\n\t\t\t\tvar change = macro itInclude($s, function($n, __status) $f);\r\n\t\t\t\te.expr = change.expr;\r\n\t\t\t\tf.iter(injectAsync);\r\n\r\n\t\t\tcase macro it($s, function($n) $f):\r\n\t\t\t\tvar change = macro it($s, function($n, __status) $f);\r\n\t\t\t\te.expr = change.expr;\r\n\t\t\t\tf.iter(injectAsync);\r\n\r\n\t\t\t/////\r\n\r\n\t\t\tcase macro @include it($s, function() $f), macro @include it($s, $f):\r\n\t\t\t\tvar change = macro syncItInclude($s, function(__asyncDone, __status) $f);\r\n\t\t\t\te.expr = change.expr;\r\n\t\t\t\tf.iter(injectAsync);\r\n\r\n\t\t\tcase macro it($s, function() $f), macro it($s, $f):\r\n\t\t\t\tvar change = macro syncIt($s, function(__asyncDone, __status) $f);\r\n\t\t\t\te.expr = change.expr;\r\n\t\t\t\tf.iter(injectAsync);\r\n\r\n\t\t\t/////\r\n\r\n\t\t\tcase macro xit($s, function($n) $f):\r\n\t\t\t\tvar change = macro xit($s, function($n, __status) $f);\r\n\t\t\t\te.expr = change.expr;\r\n\t\t\t\tf.iter(injectAsync);\r\n\r\n\t\t\tcase macro xit($s, function() $f), macro xit($s, $f), macro @exclude it($s, function() $f), macro @exclude it($s, $f):\r\n\t\t\t\tvar change = macro syncXit($s, function(__asyncDone, __status) $f);\r\n\t\t\t\te.expr = change.expr;\r\n\t\t\t\tf.iter(injectAsync);\r\n\r\n\t\t\tcase _: e.iter(injectAsync);\r\n\t\t}\r\n\t}\r\n\r\n\tmacro public static function build() : Array<Field>\r\n\t{\r\n\t\tvar exists = false;\r\n\t\tvar cls = Context.getLocalClass();\r\n\t\tif (cls == null || cls.get().superClass == null) return null;\r\n\r\n\t\tvar fields = Context.getBuildFields();\r\n\t\tfor (f in fields)\r\n\t\t{\r\n\t\t\tif (f.name != \"new\") continue;\r\n\t\t\tswitch(f.kind)\r\n\t\t\t{\r\n\t\t\t\tcase FFun(f):\r\n\t\t\t\t\tswitch(f.expr.expr)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcase EBlock(exprs):\r\n\t\t\t\t\t\t\tfor (e in exprs)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tswitch(e)\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t// Replace before/after outside describe with corresponding init functions.\r\n\r\n\t\t\t\t\t\t\t\t\tcase macro before(function($n) $f):\r\n\t\t\t\t\t\t\t\t\t\tvar change = macro beforeDescribe(function($n, __status) $f);\r\n\t\t\t\t\t\t\t\t\t\te.expr = change.expr;\r\n\r\n\t\t\t\t\t\t\t\t\tcase macro before(function() $f), macro before($f):\r\n\t\t\t\t\t\t\t\t\t\tvar change = macro syncBeforeDescribe(function(__asyncDone, __status) $f);\r\n\t\t\t\t\t\t\t\t\t\te.expr = change.expr;\r\n\r\n\t\t\t\t\t\t\t\t\tcase macro after(function($n) $f):\r\n\t\t\t\t\t\t\t\t\t\tvar change = macro afterDescribe(function($n, __status) $f);\r\n\t\t\t\t\t\t\t\t\t\te.expr = change.expr;\r\n\r\n\t\t\t\t\t\t\t\t\tcase macro after(function() $f), macro after($f):\r\n\t\t\t\t\t\t\t\t\t\tvar change = macro syncAfterDescribe(function(__asyncDone, __status) $f);\r\n\t\t\t\t\t\t\t\t\t\te.expr = change.expr;\r\n\r\n\t\t\t\t\t\t\t\t\t// Test if a super call exists.\r\n\r\n\t\t\t\t\t\t\t\t\tcase macro super():\r\n\t\t\t\t\t\t\t\t\t\texists = true;\r\n\r\n\t\t\t\t\t\t\t\t\tcase _:\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif(!exists)\r\n\t\t\t\t\t\t\t\texprs.unshift(macro super());\r\n\r\n\t\t\t\t\t\tcase _:\r\n\t\t\t\t\t}\r\n\t\t\t\t\tf.expr.iter(injectAsync);\r\n\r\n\t\t\t\tcase _:\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn fields;\r\n\t}\r\n}\r\n#end\r\n","package buddy ;\r\n\r\n#if macro\r\nimport buddy.reporting.ConsoleReporter;\r\nimport buddy.SuitesRunner;\r\nimport haxe.macro.Compiler;\r\nimport haxe.macro.Expr;\r\nimport haxe.macro.ExprTools;\r\nimport haxe.macro.Type;\r\nimport haxe.macro.Context;\r\nimport haxe.rtti.Meta;\r\nusing haxe.macro.ExprTools;\r\nimport buddy.tools.AutoIncluder;\r\nusing Lambda;\r\n\r\nclass GenerateMain\r\n{\r\n\tmacro public static function build( ?packages:Array<String> ) : Array<Field>\r\n\t{\r\n\t\tvar cls = Context.getLocalClass().get();\r\n\t\tvar fields = Context.getBuildFields();\r\n\t\tvar found = false;\r\n\r\n\t\tAutoIncluder.run(cls, packages, typeIsSuite);\r\n\r\n\t\tfor (f in fields)\r\n\t\t{\r\n\t\t\tif (f.name == \"main\" && f.access.exists(function(a) { return a == Access.AStatic; } ))\r\n\t\t\t{\r\n\t\t\t\tswitch(f.kind)\r\n\t\t\t\t{\r\n\t\t\t\t\tcase FFun(f2):\r\n\t\t\t\t\t\tswitch(f2.expr.expr)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tcase EBlock(exprs):\r\n\t\t\t\t\t\t\t\tfound = true;\r\n\t\t\t\t\t\t\t\tbuildMain(exprs, cls);\r\n\t\t\t\t\t\t\tcase _:\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\tcase _:\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!found)\r\n\t\t{\r\n\t\t\tvar body = macro {};\r\n\t\t\tswitch(body.expr)\r\n\t\t\t{\r\n\t\t\t\tcase EBlock(exprs):\r\n\t\t\t\t\tbuildMain(exprs, cls);\r\n\t\t\t\tcase _:\r\n\t\t\t}\r\n\r\n\t\t\tvar func = {\r\n\t\t\t\tret: null,\r\n\t\t\t\tparams: [],\r\n\t\t\t\texpr: body,\r\n\t\t\t\targs: []\r\n\t\t\t};\r\n\r\n\t\t\tvar main = {\r\n\t\t\t\tpos: Context.currentPos(),\r\n\t\t\t\tname: \"main\",\r\n\t\t\t\tmeta: [],\r\n\t\t\t\tkind: FFun(func),\r\n\t\t\t\tdoc: null,\r\n\t\t\t\taccess: [Access.AStatic, Access.APublic]\r\n\t\t\t};\r\n\r\n\t\t\tfields.push(main);\r\n\t\t}\r\n\r\n\t\treturn fields;\r\n\t}\r\n\r\n\tprivate static function typeIsSuite(classes : Array<ClassType>) : Array<ClassType>\r\n\t{\r\n\t\tvar output = new Array<ClassType>();\r\n\t\tvar include = new Array<ClassType>();\r\n\r\n\t\tfor (c in classes)\r\n\t\t{\r\n\t\t\tif (c.meta.has(BuddySuite.exclude)) continue;\r\n\t\t\tif (c.superClass != null && c.superClass.t.get().name == \"BuddySuite\")\r\n\t\t\t{\r\n\t\t\t\tif (c.meta.has(BuddySuite.include)) include.push(c);\r\n\t\t\t\telse output.push(c);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn include.length > 0 ? include : output;\r\n\t}\r\n\r\n\tprivate static function buildMain(exprs : Array<Expr>, cls : ClassType)\r\n\t{\r\n\t\tvar e = AutoIncluder.toTypeStringExpr(cls);\r\n\t\tvar body : Expr;\r\n\r\n\t\tif (Context.defined(\"neko\") || Context.defined(\"cpp\"))\r\n\t\t{\r\n\t\t\tbody = macro {\r\n\t\t\t\tvar reporter = new buddy.reporting.ConsoleReporter();\r\n\t\t\t\tvar suites = [];\r\n\t\t\t\tfor (a in haxe.rtti.Meta.getType(Type.resolveClass($e)).autoIncluded) {\r\n\t\t\t\t\tsuites.push(Type.createInstance(Type.resolveClass(a), []));\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar testsRunning = true;\r\n\t\t\t\tvar runner = new buddy.SuitesRunner(suites, reporter);\r\n\r\n\t\t\t\trunner.run().then(function(_) { testsRunning = false; } );\r\n\t\t\t\twhile (testsRunning) Sys.sleep(0.1);\r\n\t\t\t\tSys.exit(runner.statusCode());\r\n\t\t\t};\r\n\t\t}\r\n\t\telse if(Context.defined(\"cs\"))\r\n\t\t{\r\n\t\t\tbody = macro {\r\n\t\t\t\tvar reporter = new buddy.reporting.ConsoleReporter();\r\n\t\t\t\tvar suites = [];\r\n\t\t\t\tfor (a in haxe.rtti.Meta.getType(Type.resolveClass($e)).autoIncluded) {\r\n\t\t\t\t\tsuites.push(Type.createInstance(Type.resolveClass(a), []));\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar testsRunning = true;\r\n\t\t\t\tvar runner = new buddy.SuitesRunner(suites, reporter);\r\n\r\n\t\t\t\trunner.run().then(function(_) { testsRunning = false; } );\r\n\t\t\t\twhile (testsRunning) cs.system.threading.Thread.Sleep(10);\r\n\t\t\t\tcs.system.Environment.Exit(runner.statusCode());\r\n\t\t\t};\r\n\t\t}\r\n\t\telse if(Context.defined(\"nodejs\"))\r\n\t\t{\r\n\t\t\tbody = macro {\r\n\t\t\t\tvar reporter = new buddy.reporting.ConsoleReporter();\r\n\t\t\t\tvar suites = [];\r\n\t\t\t\tfor (a in haxe.rtti.Meta.getType(Type.resolveClass($e)).autoIncluded) {\r\n\t\t\t\t\tsuites.push(Type.createInstance(Type.resolveClass(a), []));\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar runner = new buddy.SuitesRunner(suites, reporter);\r\n\r\n\t\t\t\t// Windows bug doesn't flush stdout properly, need to wait: https://github.com/joyent/node/issues/3584\r\n\t\t\t\trunner.run().then(function(_) { untyped __js__(\"if(process.platform == 'win32') { process.once('exit', function() { process.exit(runner.statusCode()); }); } else { process.exit(runner.statusCode()); }\"); } );\r\n\t\t\t};\r\n\t\t}\r\n\t\telse if(Context.defined(\"php\") || Context.defined(\"java\"))\r\n\t\t{\r\n\t\t\tbody = macro {\r\n\t\t\t\tvar reporter = new buddy.reporting.ConsoleReporter();\r\n\t\t\t\tvar suites = [];\r\n\t\t\t\tfor (a in haxe.rtti.Meta.getType(Type.resolveClass($e)).autoIncluded) {\r\n\t\t\t\t\tsuites.push(Type.createInstance(Type.resolveClass(a), []));\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar runner = new buddy.SuitesRunner(suites, reporter);\r\n\t\t\t\trunner.run().then(function(_) { Sys.exit(runner.statusCode()); });\r\n\t\t\t};\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tbody = macro {\r\n\t\t\t\tvar reporter = new buddy.reporting.ConsoleReporter();\r\n\t\t\t\tvar suites = [];\r\n\t\t\t\tfor (a in haxe.rtti.Meta.getType(Type.resolveClass($e)).autoIncluded) {\r\n\t\t\t\t\tsuites.push(Type.createInstance(Type.resolveClass(a), []));\r\n\t\t\t\t}\r\n\r\n\t\t\t\tnew buddy.SuitesRunner(suites, reporter).run();\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\texprs.push(body);\r\n\t}\r\n}\r\n#end\r\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\nenum ValueType {\n\tTNull;\n\tTInt;\n\tTFloat;\n\tTBool;\n\tTObject;\n\tTFunction;\n\tTClass( c : Class<Dynamic> );\n\tTEnum( e : Enum<Dynamic> );\n\tTUnknown;\n}\n\n@:coreApi class Type {\n\n\tpublic static function getClass<T>( o : T ) : Class<T> untyped {\n\t\tif( o == null )\n\t\t\treturn null;\n\t\treturn js.Boot.getClass(o);\n\t}\n\n\tpublic static function getEnum( o : EnumValue ) : Enum<Dynamic> untyped {\n\t\tif( o == null )\n\t\t\treturn null;\n\t\treturn o.__enum__;\n\t}\n\n\tpublic static function getSuperClass( c : Class<Dynamic> ) : Class<Dynamic> untyped {\n\t\treturn c.__super__;\n\t}\n\n\n\tpublic static function getClassName( c : Class<Dynamic> ) : String {\n\t\tvar a : Array<String> = untyped c.__name__;\n\t\treturn a.join(\".\");\n\t}\n\n\tpublic static function getEnumName( e : Enum<Dynamic> ) : String {\n\t\tvar a : Array<String> = untyped e.__ename__;\n\t\treturn a.join(\".\");\n\t}\n\n\tpublic static function resolveClass( name : String ) : Class<Dynamic> untyped {\n\t\tvar cl : Class<Dynamic> = $hxClasses[name];\n\t\t// ensure that this is a class\n\t\tif( cl == null || !js.Boot.isClass(cl) )\n\t\t\treturn null;\n\t\treturn cl;\n\t}\n\n\tpublic static function resolveEnum( name : String ) : Enum<Dynamic> untyped {\n\t\tvar e : Dynamic = $hxClasses[name];\n\t\t// ensure that this is an enum\n\t\tif( e == null || !js.Boot.isEnum(e) )\n\t\t\treturn null;\n\t\treturn e;\n\t}\n\n\tpublic static function createInstance<T>( cl : Class<T>, args : Array<Dynamic> ) : T untyped {\n\t\tswitch( args.length ) {\n\t\tcase 0:\n\t\t\treturn __new__(cl);\n\t\tcase 1:\n\t\t\treturn __new__(cl,args[0]);\n\t\tcase 2:\n\t\t\treturn __new__(cl,args[0],args[1]);\n\t\tcase 3:\n\t\t\treturn __new__(cl,args[0],args[1],args[2]);\n\t\tcase 4:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3]);\n\t\tcase 5:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3],args[4]);\n\t\tcase 6:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3],args[4],args[5]);\n\t\tcase 7:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3],args[4],args[5],args[6]);\n\t\tcase 8:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7]);\n\t\tdefault:\n\t\t\tthrow \"Too many arguments\";\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static function createEmptyInstance<T>( cl : Class<T> ) : T untyped {\n\t\t__js__(\"function empty() {}; empty.prototype = cl.prototype\");\n\t\treturn __js__(\"new empty()\");\n\t}\n\n\tpublic static function createEnum<T>( e : Enum<T>, constr : String, ?params : Array<Dynamic> ) : T {\n\t\tvar f = Reflect.field(e,constr);\n\t\tif( f == null ) throw \"No such constructor \"+constr;\n\t\tif( Reflect.isFunction(f) ) {\n\t\t\tif( params == null ) throw \"Constructor \"+constr+\" need parameters\";\n\t\t\treturn Reflect.callMethod(e,f,params);\n\t\t}\n\t\tif( params != null && params.length != 0 )\n\t\t\tthrow \"Constructor \"+constr+\" does not need parameters\";\n\t\treturn f;\n\t}\n\n\tpublic static function createEnumIndex<T>( e : Enum<T>, index : Int, ?params : Array<Dynamic> ) : T {\n\t\tvar c : String = (untyped e.__constructs__)[index];\n\t\tif( c == null ) throw index+\" is not a valid enum constructor index\";\n\t\treturn createEnum(e,c,params);\n\t}\n\n\tpublic static function getInstanceFields( c : Class<Dynamic> ) : Array<String> {\n\t\tvar a = [];\n\t\tuntyped __js__(\"for(var i in c.prototype) a.push(i)\");\n\t\ta.remove(\"__class__\");\n\t\ta.remove(\"__properties__\");\n\t\treturn a;\n\t}\n\n\tpublic static function getClassFields( c : Class<Dynamic> ) : Array<String> {\n\t\tvar a = Reflect.fields(c);\n\t\ta.remove(\"__name__\");\n\t\ta.remove(\"__interfaces__\");\n\t\ta.remove(\"__properties__\");\n\t\ta.remove(\"__super__\");\n\t\ta.remove(\"prototype\");\n\t\treturn a;\n\t}\n\n\tpublic static function getEnumConstructs( e : Enum<Dynamic> ) : Array<String> {\n\t\tvar a : Array<String> = untyped e.__constructs__;\n\t\treturn a.copy();\n\t}\n\n\tpublic static function typeof( v : Dynamic ) : ValueType untyped {\n\t\tswitch( __js__(\"typeof\")(v) ) {\n\t\tcase \"boolean\": return TBool;\n\t\tcase \"string\": return TClass(String);\n\t\tcase \"number\":\n\t\t\t// this should handle all cases : NaN, +/-Inf and Floats outside range\n\t\t\tif( Math.ceil(v) == v%2147483648.0 )\n\t\t\t\treturn TInt;\n\t\t\treturn TFloat;\n\t\tcase \"object\":\n\t\t\tif( v == null )\n\t\t\t\treturn TNull;\n\t\t\tvar e = v.__enum__;\n\t\t\tif( e != null )\n\t\t\t\treturn TEnum(e);\n\t\t\tvar c = js.Boot.getClass(v);\n\t\t\tif( c != null )\n\t\t\t\treturn TClass(c);\n\t\t\treturn TObject;\n\t\tcase \"function\":\n\t\t\tif( js.Boot.isClass(v) || js.Boot.isEnum(v) )\n\t\t\t\treturn TObject;\n\t\t\treturn TFunction;\n\t\tcase \"undefined\":\n\t\t\treturn TNull;\n\t\tdefault:\n\t\t\treturn TUnknown;\n\t\t}\n\t}\n\n\tpublic static function enumEq<T>( a : T, b : T ) : Bool untyped {\n\t\tif( a == b )\n\t\t\treturn true;\n\t\ttry {\n\t\t\tif( a[0] != b[0] )\n\t\t\t\treturn false;\n\t\t\tfor( i in 2...a.length )\n\t\t\t\tif( !enumEq(a[i],b[i]) )\n\t\t\t\t\treturn false;\n\t\t\tvar e = a.__enum__;\n\t\t\tif( e != b.__enum__ || e == null )\n\t\t\t\treturn false;\n\t\t} catch( e : Dynamic ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic inline static function enumConstructor( e : EnumValue ) : String {\n\t\treturn untyped e[0];\n\t}\n\n\tpublic inline static function enumParameters( e : EnumValue ) : Array<Dynamic> {\n\t\treturn untyped e.slice(2);\n\t}\n\n\tpublic inline static function enumIndex( e : EnumValue ) : Int {\n\t\treturn untyped e[1];\n\t}\n\n\tpublic static function allEnums<T>( e : Enum<T> ) : Array<T> {\n\t\treturn untyped e.__empty_constructs__;\n\t}\n\n}\n\n","package buddy;\r\nimport buddy.Should.ShouldIterable;\r\nimport haxe.PosInfos;\r\nimport haxe.CallStack;\r\nusing Lambda;\r\nusing StringTools;\r\n\r\n/*\r\nX toBe(b);\r\nX toBe(false);\r\nX toBeCloseTo(e, 0);\r\n- toBeDefined();\r\n- toBeFalsy();\r\nX toBeGreaterThan(0);\r\nX toBeLessThan(e);\r\n- toBeNull();\r\n- toBeTruthy();\r\n- toBeUndefined();\r\nX toContain(\"bar\");\r\nX toEqual(\"I\");\r\ntoHaveBeenCalled();\r\ntoHaveBeenCalledWith(456, 'another param');\r\ntoHaveBeenCalledWith(jasmine.any(Number), jasmine.any(Function));\r\ntoHaveBeenCalledWith(jasmine.objectContaining({\r\nX toMatch(/bar/);\r\n- toThrow();\r\nX toThrowError(\"quux\");\r\n*/\r\n\r\n/**\r\n * A function that specifies the status for a spec with an optional error message.\r\n */\r\ntypedef SpecAssertion = Bool -> String -> Array<StackItem> -> Void;\r\n\r\n/**\r\n * This must be the first class in this package, since it overrides all other assertions otherwise.\r\n */\r\nclass ShouldDynamic extends Should<Dynamic>\r\n{\r\n\tstatic public function should<T>(d : T, assert : SpecAssertion)\r\n\t{\r\n\t\treturn new ShouldDynamic(d, assert);\r\n\t}\r\n\r\n\tpublic var not(get, never) : ShouldDynamic;\r\n\tprivate function get_not() { return new ShouldDynamic(value, assert, !inverse); }\r\n}\r\n\r\nclass ShouldInt extends Should<Int>\r\n{\r\n\tstatic public function should(i : Int, assert : SpecAssertion)\r\n\t{\r\n\t\treturn new ShouldInt(i, assert);\r\n\t}\r\n\r\n\tpublic function new(value : Int, assert : SpecAssertion, inverse = false)\r\n\t{\r\n\t\tsuper(value, assert, inverse);\r\n\t}\r\n\r\n\tpublic var not(get, never) : ShouldInt;\r\n\tprivate function get_not() { return new ShouldInt(value, assert, !inverse); }\r\n\r\n\t//////////\r\n\r\n\tpublic function beLessThan(expected : Int, ?p : PosInfos)\r\n\t{\r\n\t\ttest(value < expected, p,\r\n\t\t\t'Expected less than ${quote(expected)}, was ${quote(value)}',\r\n\t\t\t'Expected not less than ${quote(expected)}, was ${quote(value)}'\r\n\t\t);\r\n\t}\r\n\r\n\tpublic function beGreaterThan(expected : Int, ?p : PosInfos)\r\n\t{\r\n\t\ttest(value > expected, p,\r\n\t\t\t'Expected greater than ${quote(expected)}, was ${quote(value)}',\r\n\t\t\t'Expected not greater than ${quote(expected)}, was ${quote(value)}'\r\n\t\t);\r\n\t}\r\n}\r\n\r\nclass ShouldFloat extends Should<Float>\r\n{\r\n\tstatic public function should(i : Float, assert : SpecAssertion)\r\n\t{\r\n\t\treturn new ShouldFloat(i, assert);\r\n\t}\r\n\r\n\tpublic function new(value : Float, assert : SpecAssertion, inverse = false)\r\n\t{\r\n\t\tsuper(value, assert, inverse);\r\n\t}\r\n\r\n\tpublic var not(get, never) : ShouldFloat;\r\n\tprivate function get_not() { return new ShouldFloat(value, assert, !inverse); }\r\n\r\n\t//////////\r\n\r\n\tpublic function beLessThan(expected : Float, ?p : PosInfos)\r\n\t{\r\n\t\ttest(value < expected, p,\r\n\t\t\t'Expected less than ${quote(expected)}, was ${quote(value)}',\r\n\t\t\t'Expected not less than ${quote(expected)}, was ${quote(value)}'\r\n\t\t);\r\n\t}\r\n\r\n\tpublic function beGreaterThan(expected : Float, ?p : PosInfos)\r\n\t{\r\n\t\ttest(value > expected, p,\r\n\t\t\t'Expected greater than ${quote(expected)}, was ${quote(value)}',\r\n\t\t\t'Expected not greater than ${quote(expected)}, was ${quote(value)}'\r\n\t\t);\r\n\t}\r\n\r\n\tpublic function beCloseTo(expected : Float, precision : Null<Float> = 2, ?p : PosInfos)\r\n\t{\r\n\t\t// For some reason, precision must be of a Nullable type in flash or it will be 0 sometimes?!\r\n\t\tvar expr = Math.abs(expected - value) < (Math.pow(10, -precision) / 2);\r\n\r\n\t\ttest(expr, p,\r\n\t\t\t'Expected close to ${quote(expected)}, was ${quote(value)}',\r\n\t\t\t'Expected ${quote(value)} not to be close to ${quote(expected)}'\r\n\t\t);\r\n\t}\r\n}\r\n\r\nclass ShouldString extends Should<String>\r\n{\r\n\tstatic public function should(str : String, assert : SpecAssertion)\r\n\t{\r\n\t\treturn new ShouldString(str, assert);\r\n\t}\r\n\r\n\tpublic function new(value : String, assert : SpecAssertion, inverse = false)\r\n\t{\r\n\t\tsuper(value, assert, inverse);\r\n\t}\r\n\r\n\tpublic var not(get, never) : ShouldString;\r\n\tprivate function get_not() { return new ShouldString(value, assert, !inverse); }\r\n\r\n\t//////////\r\n\r\n\tpublic function contain(substring : String, ?p : PosInfos)\r\n\t{\r\n\t\ttest(value.indexOf(substring) >= 0, p,\r\n\t\t\t'Expected ${quote(value)} to contain ${quote(substring)}',\r\n\t\t\t'Expected ${quote(value)} not to contain ${quote(substring)}'\r\n\t\t);\r\n\t}\r\n\r\n\tpublic function startWith(substring : String, ?p : PosInfos)\r\n\t{\r\n\t\ttest(value.startsWith(substring), p,\r\n\t\t\t'Expected ${quote(value)} to start with ${quote(substring)}',\r\n\t\t\t'Expected ${quote(value)} not to start with ${quote(substring)}'\r\n\t\t);\r\n\t}\r\n\r\n\tpublic function endWith(substring : String, ?p : PosInfos)\r\n\t{\r\n\t\ttest(value.endsWith(substring), p,\r\n\t\t\t'Expected ${quote(value)} to end with ${quote(substring)}',\r\n\t\t\t'Expected ${quote(value)} not to end with ${quote(substring)}'\r\n\t\t);\r\n\t}\r\n\r\n\tpublic function match(regexp : EReg, ?p : PosInfos)\r\n\t{\r\n\t\ttest(regexp.match(value), p,\r\n\t\t\t'Expected ${quote(value)} to match regular expression',\r\n\t\t\t'Expected ${quote(value)} not to match regular expression'\r\n\t\t);\r\n\t}\r\n}\r\n\r\nclass ShouldIterable<T> extends Should<Iterable<T>>\r\n{\r\n\tstatic public function should<T>(value : Iterable<T>, assert : SpecAssertion)\r\n\t{\r\n\t\treturn new ShouldIterable<T>(value, assert);\r\n\t}\r\n\r\n\tpublic function new(value : Iterable<T>, assert : SpecAssertion, inverse = false)\r\n\t{\r\n\t\tsuper(value, assert, inverse);\r\n\t}\r\n\r\n\tpublic var not(get, never) : ShouldIterable<T>;\r\n\tprivate function get_not() { return new ShouldIterable<T>(value, assert, !inverse); }\r\n\r\n\t//////////\r\n\r\n\tpublic function contain(o : T, ?p : PosInfos)\r\n\t{\r\n\t\ttest(Lambda.exists(value, function(el) return el == o), p,\r\n\t\t\t'Expected ${quote(value)} to contain ${quote(o)}',\r\n\t\t\t'Expected ${quote(value)} not to contain ${quote(o)}'\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * Test if iterable contains all of the following values.\r\n\t */\r\n\tpublic function containAll(values : Iterable<T>, ?p : PosInfos)\r\n\t{\r\n\t\tvar expr = true;\r\n\r\n\t\t// Having problem with java compilation for Lambda, using a simpler version:\r\n\t\tfor (a in values)\r\n\t\t{\r\n\t\t\tif (!value.exists(function(v) { return v == a; } ))\r\n\t\t\t{\r\n\t\t\t\texpr = false;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\ttest(expr, p,\r\n\t\t\t'Expected ${quote(value)} to contain all of ${quote(values)}',\r\n\t\t\t'Expected ${quote(value)} not to contain all of ${quote(values)}'\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * Test if iterable contains exactly the following values and in the same iteration order.\r\n\t */\r\n\tpublic function containExactly(values : Iterable<T>, ?p : PosInfos)\r\n\t{\r\n\t\tvar a = value.iterator();\r\n\t\tvar b = values.iterator();\r\n\t\tvar expr = true;\r\n\r\n\t\twhile (a.hasNext() || b.hasNext())\r\n\t\t{\r\n\t\t\tif (a.next() != b.next())\r\n\t\t\t{\r\n\t\t\t\texpr = false;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\ttest(expr, p,\r\n\t\t\t'Expected ${quote(value)} to contain exactly ${quote(values)}',\r\n\t\t\t'Expected ${quote(value)} not to contain exactly ${quote(values)}'\r\n\t\t);\r\n\t}\r\n}\r\n\r\n// Some problem with C++ forces this class not to be derived from Should<T>\r\nclass ShouldFunctions\r\n{\r\n\tvar value : Void -> Void;\r\n\tvar assert : SpecAssertion;\r\n\tvar inverse : Bool;\r\n\r\n\tpublic function new(value : Void -> Void, assert : SpecAssertion, inverse = false)\r\n\t{\r\n\t\tthis.value = value;\r\n\t\tthis.assert = assert;\r\n\t\tthis.inverse = inverse;\r\n\t}\r\n\r\n\tpublic var not(get, never) : ShouldFunctions;\r\n\tprivate function get_not() { return new ShouldFunctions(value, assert, !inverse); }\r\n\r\n\tstatic public function should(value : Void -> Void, assert : SpecAssertion)\r\n\t{\r\n\t\treturn new ShouldFunctions(value, assert);\r\n\t}\r\n\r\n\t/**\r\n\t * Will call the specified method and test if it throws a specific value.\r\n\t */\r\n\tpublic function throwValue(v : Dynamic, ?p : PosInfos)\r\n\t{\r\n\t\tvar expr = false;\r\n\t\ttry { value(); }\r\n\t\tcatch (e : Dynamic)\r\n\t\t{\r\n\t\t\texpr = e == v;\r\n\t\t}\r\n\r\n\t\ttest(expr, p,\r\n\t\t\t'Expected ${quote(value)} to throw ${quote(v)}',\r\n\t\t\t'Expected ${quote(value)} not to throw ${quote(v)}'\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * Will call the specified method and test if it throws a specific type.\r\n\t */\r\n\tpublic function throwType(type : Class<Dynamic>, ?p : PosInfos)\r\n\t{\r\n\t\tvar expr = false;\r\n\t\tvar name : String = null;\r\n\r\n\t\ttry { value(); }\r\n\t\tcatch (e : Dynamic)\r\n\t\t{\r\n\t\t\tname = Type.getClassName(type);\r\n\t\t\texpr = Std.is(e, type);\r\n\t\t}\r\n\r\n\t\ttest(expr, p,\r\n\t\t\t'Expected ${quote(value)} to throw type $name',\r\n\t\t\t'Expected ${quote(value)} not to throw type $name'\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * Test for equality between two value types (bool, int, float), or identity for reference types\r\n\t */\r\n\tpublic function be(expected : Void -> Void, ?p : PosInfos) : Void\r\n\t{\r\n\t\ttest(value == expected, p,\r\n\t\t\t'Expected ${quote(expected)}, was ${quote(value)}',\r\n\t\t\t'Didn\\'t expect ${quote(expected)} but was equal to that'\r\n\t\t);\r\n\t}\r\n\r\n\tprivate function quote(v : Dynamic)\r\n\t{\r\n\t\treturn Std.is(v, String) ? '\"$v\"' : Std.string(v);\r\n\t}\r\n\r\n\tprivate function stackPos(p : PosInfos)\r\n\t{\r\n\t\treturn [StackItem.FilePos(null, p.fileName, p.lineNumber)];\r\n\t}\r\n\r\n\tprivate function test(expr : Bool, p : PosInfos, error : String, errorInverted : String)\r\n\t{\r\n\t\tif(!inverse)\r\n\t\t\tassert(expr, error, stackPos(p));\r\n\t\telse\r\n\t\t\tassert(!expr, errorInverted, stackPos(p));\r\n\t}\r\n}\r\n\r\n//////////\r\n\r\nclass Should<T>\r\n{\r\n\tvar value : T;\r\n\tvar assert : SpecAssertion;\r\n\tvar inverse : Bool;\r\n\r\n\tpublic function new(value : T, assert : SpecAssertion, inverse = false)\r\n\t{\r\n\t\tthis.value = value;\r\n\t\tthis.assert = assert;\r\n\t\tthis.inverse = inverse;\r\n\t}\r\n\r\n\t/**\r\n\t * Test for equality between two value types (bool, int, float), or identity for reference types\r\n\t */\r\n\tpublic function be(expected : T, ?p : PosInfos) : Void\r\n\t{\r\n\t\ttest(value == expected, p,\r\n\t\t\t'Expected ${quote(expected)}, was ${quote(value)}',\r\n\t\t\t'Didn\\'t expect ${quote(expected)} but was equal to that'\r\n\t\t);\r\n\t}\r\n\r\n\tprivate function quote(v : Dynamic)\r\n\t{\r\n\t\treturn Std.is(v, String) ? '\"$v\"' : Std.string(v);\r\n\t}\r\n\r\n\tprivate function stackPos(p : PosInfos)\r\n\t{\r\n\t\treturn [StackItem.FilePos(null, p.fileName, p.lineNumber)];\r\n\t}\r\n\r\n\tprivate function test(expr : Bool, p : PosInfos, error : String, errorInverted : String)\r\n\t{\r\n\t\tif(!inverse)\r\n\t\t\tassert(expr, error, stackPos(p));\r\n\t\telse\r\n\t\t\tassert(!expr, errorInverted, stackPos(p));\r\n\t}\r\n}\r\n","package buddy ;\r\nimport buddy.internal.SuiteRunner;\r\nimport buddy.reporting.Reporter;\r\nimport haxe.rtti.Meta;\r\nimport promhx.Deferred;\r\nimport promhx.Promise;\r\nimport buddy.BuddySuite;\r\nusing buddy.tools.AsyncTools;\r\n\r\n@:keep // prevent dead code elimination\r\nclass SuitesRunner\r\n{\r\n\tprivate var suites : Iterable<Suite>;\r\n\tprivate var reporter : Reporter;\r\n\r\n\tpublic function new(buddySuites : Iterable<BuddySuite>, reporter : Reporter)\r\n\t{\r\n\t\t// Cannot use Lambda here, Java problem in Linux.\r\n\t\tvar includeMode = [for (b in buddySuites) for (s in b.suites) if (s.include) s].length > 0;\r\n\r\n\t\tthis.suites = [for (b in buddySuites) for (s in b.suites) if(!includeMode || s.include) s];\r\n\t\tthis.reporter = reporter;\r\n\t}\r\n\r\n\tpublic function run() : Promise<Bool>\r\n\t{\r\n\t\tvar def = new Deferred<Bool>();\r\n\t\tvar defPr = def.promise();\r\n\r\n\t\treporter.start().then(function(ok) {\r\n\t\t\tif(ok)\r\n\t\t\t{\r\n\t\t\t\tsuites.iterateAsyncBool(runSuite)\r\n\t\t\t\t\t.pipe(function(_) return reporter.done(suites))\r\n\t\t\t\t\t.then(function(_) def.resolve(ok));\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tdef.resolve(ok);\r\n\t\t});\r\n\r\n\t\treturn defPr;\r\n\t}\r\n\r\n\tpublic function failed() : Bool\r\n\t{\r\n\t\tfor(s in suites) for (sp in s.specs)\r\n\t\t\tif (sp.status == TestStatus.Failed) return true;\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tpublic function statusCode() : Int\r\n\t{\r\n\t\treturn failed() ? 1 : 0;\r\n\t}\r\n\r\n\tprivate function runSuite(suite : Suite) : Promise<Suite>\r\n\t{\r\n\t\treturn new SuiteRunner(suite, reporter).run();\r\n\t}\r\n}\r\n","package buddy.internal;\r\nimport buddy.BuddySuite;\r\nimport buddy.reporting.Reporter;\r\nimport haxe.CallStack;\r\nimport haxe.Log;\r\nimport haxe.PosInfos;\r\nimport promhx.Deferred;\r\nimport promhx.Promise;\r\n\r\n#if utest\r\nimport utest.Assert;\r\nimport utest.Assertation;\r\n#end\r\n\r\nusing buddy.tools.AsyncTools;\r\n\r\nclass SuiteRunner\r\n{\r\n\tvar buddySuite : BuddySuite;\r\n\tvar suite : Suite;\r\n\tvar reporter : Reporter;\r\n\r\n\tpublic function new(suite : Suite, reporter : Reporter)\r\n\t{\r\n\t\tthis.buddySuite = suite.buddySuite;\r\n\t\tthis.suite = suite;\r\n\t\tthis.reporter = reporter;\r\n\t}\r\n\r\n\tpublic function run() : Promise<Suite>\r\n\t{\r\n\t\tvar traceFunc = Log.trace;\r\n\t\tvar def = new Deferred<Suite>();\r\n\t\tvar pr = def.promise();\r\n\r\n\t\tbuddySuite.befores.iterateAsyncBool(runBeforeAfter)\r\n\t\t\t.pipe(function(_) return suite.specs.iterateAsyncBool(runSpec))\r\n\t\t\t.pipe(function(_) return buddySuite.afters.iterateAsyncBool(runBeforeAfter))\r\n\t\t\t.then(function(_) { Log.trace = traceFunc; def.resolve(suite); });\r\n\r\n\t\treturn pr;\r\n\t}\r\n\r\n\tprivate function runBeforeAfter(b : BeforeAfter) : Promise<BeforeAfter>\r\n\t{\r\n\t\tvar def = new Deferred<BeforeAfter>();\r\n\t\tvar pr = def.promise();\r\n\t\tvar done = function() { def.resolve(b); };\r\n\r\n\t\tb.run(done, function(s, err, stack) {});\r\n\t\tif (!b.async) done();\r\n\r\n\t\treturn pr;\r\n\t}\r\n\r\n\tprivate function runSpec(spec : Spec) : Promise<Spec>\r\n\t{\r\n\t\t// Spec = The whole spec (before, it, after)\r\n\t\tvar specDone = new Deferred<Spec>();\r\n\t\tvar specPr = specDone.promise();\r\n\r\n\t\tspecPr.pipe(function(s) {\r\n\t\t\treturn this.reporter != null ? reporter.progress(s) : specPr;\r\n\t\t});\r\n\r\n\t\tif (spec.status != TestStatus.Unknown)\r\n\t\t{\r\n\t\t\tspecDone.resolve(spec);\r\n\t\t\treturn specPr;\r\n\t\t}\r\n\r\n\t\t// It = The it part only\r\n\t\tvar itDone = new Deferred<{status: TestStatus, error: String, stack: Array<StackItem>}>();\r\n\t\tvar itPromise = itDone.promise();\r\n\r\n\t\t// The function that sets test status\r\n\t\tvar hasStatus = false;\r\n\t\tvar status = function(s, error, stack)\r\n\t\t{\r\n\t\t\thasStatus = true;\r\n\t\t\tif (!s && !itPromise.isResolved())\r\n\t\t\t\titDone.resolve( { status: TestStatus.Failed, error: error, stack: stack } );\r\n\t\t};\r\n\r\n\t\t// The function that should be called when an async operation has completed.\r\n\t\tvar done = function()\r\n\t\t{\r\n\t\t\t#if utest\r\n\t\t\tfor (a in Assert.results)\r\n\t\t\t{\r\n\t\t\t\tswitch a {\r\n\t\t\t\t\tcase Success(_):\r\n\t\t\t\t\t\thasStatus = true;\r\n\t\t\t\t\tcase Failure(e, pos):\r\n\t\t\t\t\t\tvar stack = [StackItem.FilePos(null, pos.fileName, pos.lineNumber)];\r\n\t\t\t\t\t\tstatus(false, Std.string(e), stack);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase Error(e, stack), SetupError(e, stack), TeardownError(e, stack), AsyncError(e, stack):\r\n\t\t\t\t\t\tstatus(false, Std.string(e), stack);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase TimeoutError(e, stack):\r\n\t\t\t\t\t\tstatus(false, Std.string(e), stack);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase Warning(_):\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t#end\r\n\r\n\t\t\tif (!itPromise.isResolved())\r\n\t\t\t\titDone.resolve( { status: hasStatus ? TestStatus.Passed : TestStatus.Pending, error: null, stack: null } );\r\n\t\t};\r\n\r\n\t\tLog.trace = function(v, ?pos : PosInfos) {\r\n\t\t\tspec.traces.add(pos.fileName + \":\" + pos.lineNumber + \": \" + Std.string(v));\r\n\t\t};\r\n\r\n\t\tvar errorTimeout : Promise<Bool> = null;\r\n\t\tsuite.before.iterateAsyncBool(runBeforeAfter)\r\n\t\t\t.pipe(function(_)\r\n\t\t\t{\r\n\t\t\t\tif (spec.async)\r\n\t\t\t\t{\r\n\t\t\t\t\tvar timeout = buddySuite.timeoutMs;\r\n\t\t\t\t\terrorTimeout = AsyncTools.wait(timeout);\r\n\r\n\t\t\t\t\t// This promise will be rejected if done is called before timeout occurs.\r\n\t\t\t\t\terrorTimeout\r\n\t\t\t\t\t\t.catchError(function(e : Dynamic) if(e != null) throw e)\r\n\t\t\t\t\t\t.then(function(_) {\r\n\t\t\t\t\t\t\tstatus(false, 'Timeout after $timeout ms', null);\r\n\t\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttry {\r\n\t\t\t\t\t#if utest\r\n\t\t\t\t\tAssert.results = new List<Assertation>();\r\n\t\t\t\t\t#end\r\n\t\t\t\t\tspec.run(done, status);\r\n\t\t\t\t\tif (!spec.async) done();\r\n\t\t\t\t}\r\n\t\t\t\tcatch (e : Dynamic) {\r\n\t\t\t\t\tstatus(false, Std.string(e), CallStack.exceptionStack());\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn itPromise;\r\n\t\t\t})\r\n\t\t\t.pipe(function(result)\r\n\t\t\t{\r\n\t\t\t\tif (errorTimeout != null)\r\n\t\t\t\t{\r\n\t\t\t\t\terrorTimeout.reject(null);\r\n\t\t\t\t\terrorTimeout = null;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tspec.setStatus(result.status, result.error, result.stack);\r\n\t\t\t\treturn suite.after.iterateAsyncBool(runBeforeAfter);\r\n\t\t\t})\r\n\t\t\t.then(function(_) { specDone.resolve(spec); } );\r\n\r\n\t\treturn specPr;\r\n\t}\r\n}","package buddy.internal.sys;\r\n\r\n#if nodejs\r\nclass NodeJs\r\n{\r\n\tpublic static function print(s : String)\r\n\t{\r\n\t\tuntyped __js__(\"process.stdout.write(s)\");\r\n\t}\r\n\r\n\tpublic static function println(s : String)\r\n\t{\r\n\t\tuntyped __js__(\"console.log(s)\");\r\n\t}\r\n}\r\n#end\r\n","package buddy.reporting ;\r\n\r\nimport buddy.BuddySuite;\r\nimport buddy.reporting.Reporter;\r\nimport haxe.CallStack;\r\nimport promhx.Deferred;\r\nimport promhx.Promise;\r\nusing Lambda;\r\n\r\n#if nodejs\r\nimport buddy.internal.sys.NodeJs;\r\ntypedef Sys = NodeJs;\r\n#elseif js\r\nimport buddy.internal.sys.Js;\r\ntypedef Sys = Js;\r\n#elseif flash\r\nimport buddy.internal.sys.Flash;\r\ntypedef Sys = Flash;\r\n#end\r\n\r\nclass ConsoleReporter implements Reporter\r\n{\r\n\t#if php\r\n\tvar cli : Bool;\r\n\t#end\r\n\r\n\tpublic function new() {}\r\n\r\n\tpublic function start()\r\n\t{\r\n\t\t#if php\r\n\t\tcli = (untyped __call__(\"php_sapi_name\")) == 'cli';\r\n\t\tif(!cli) Sys.println(\"<pre>\");\r\n\t\t#end\r\n\r\n\t\treturn resolveImmediately(true);\r\n\t}\r\n\r\n\tpublic function progress(spec : Spec)\r\n\t{\r\n\t\tSys.print(switch(spec.status) {\r\n\t\t\tcase TestStatus.Failed: \"X\";\r\n\t\t\tcase TestStatus.Passed: \".\";\r\n\t\t\tcase TestStatus.Pending: \"P\";\r\n\t\t\tcase TestStatus.Unknown: \"?\";\r\n\t\t});\r\n\r\n\t\treturn resolveImmediately(spec);\r\n\t}\r\n\r\n\tpublic function done(suites : Iterable<Suite>)\r\n\t{\r\n\t\tSys.println(\"\");\r\n\r\n\t\tvar total = 0;\r\n\t\tvar failures = 0;\r\n\t\tvar pending = 0;\r\n\t\tfor (s in suites)\r\n\t\t{\r\n\t\t\tfor (sp in s.specs)\r\n\t\t\t{\r\n\t\t\t\ttotal++;\r\n\t\t\t\tif (sp.status == TestStatus.Failed) failures++;\r\n\t\t\t\telse if (sp.status == TestStatus.Pending) pending++;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (s in suites)\r\n\t\t{\r\n\t\t\tSys.println(s.name);\r\n\t\t\tfor (sp in s.specs)\r\n\t\t\t{\r\n\t\t\t\tif (sp.status == TestStatus.Failed)\r\n\t\t\t\t{\r\n\t\t\t\t\tSys.println(\"  \" + sp.description + \" (FAILED: \" + sp.error + \")\");\r\n\r\n\t\t\t\t\tprintTraces(sp);\r\n\r\n\t\t\t\t\tif (sp.stack == null || sp.stack.length == 0) continue;\r\n\r\n\t\t\t\t\t// Display the exception stack\r\n\t\t\t\t\tfor (s in sp.stack) switch s {\r\n\t\t\t\t\t\tcase FilePos(_, file, line) if (file.indexOf(\"buddy/internal/\") != 0):\r\n\t\t\t\t\t\t\tSys.println('    @ $file:$line');\r\n\t\t\t\t\t\tcase _:\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tSys.println(\"  \" + sp.description + \" (\" + sp.status + \")\");\r\n\t\t\t\t\tprintTraces(sp);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tSys.println('$total specs, $failures failures, $pending pending');\r\n\r\n\t\t#if php\r\n\t\tif(!cli) Sys.println(\"</pre>\");\r\n\t\t#end\r\n\r\n\t\treturn resolveImmediately(suites);\r\n\t}\r\n\r\n\tfunction printTraces(spec : Spec)\r\n\t{\r\n\t\tfor (t in spec.traces)\r\n\t\t\tSys.println(\"    \" + t);\r\n\t}\r\n\r\n\tprivate function resolveImmediately<T>(o : T) : Promise<T>\r\n\t{\r\n\t\tvar def = new Deferred<T>();\r\n\t\tvar pr = def.promise();\r\n\t\tdef.resolve(o);\r\n\t\treturn pr;\r\n\t}\r\n}\r\n\r\n","package buddy.tools ;\r\nimport promhx.Promise;\r\nimport promhx.Deferred;\r\n\r\n#if neko\r\nimport neko.vm.Thread;\r\n#elseif cs\r\nimport cs.system.timers.ElapsedEventHandler;\r\nimport cs.system.timers.ElapsedEventArgs;\r\nimport cs.system.timers.Timer;\r\n#elseif java\r\nimport java.util.concurrent.FutureTask;\r\nimport java.util.concurrent.Callable;\r\nimport java.util.concurrent.ExecutorService;\r\nimport java.util.concurrent.Executors;\r\n#elseif cpp\r\nimport cpp.vm.Thread;\r\n#else\r\nimport haxe.Timer;\r\n#end\r\n\r\nclass AsyncTools\r\n{\r\n\tpublic static function iterateAsyncBool<T>(it : Iterable<T>, action : T -> Promise<T>) : Promise<Bool>\r\n\t{\r\n\t\treturn iterateAsync(it, action, true);\r\n\t}\r\n\r\n\tpublic static function iterateAsync<T, T2>(it : Iterable<T>, action : T -> Promise<T>, resolveWith : T2) : Promise<T2>\r\n\t{\r\n\t\tvar finished = new Deferred<T2>();\r\n\t\tvar pr = finished.promise();\r\n\t\tnext(it.iterator(), action, finished, resolveWith);\r\n\t\treturn pr;\r\n\t}\r\n\r\n\tpublic static function wait(ms : Int) : Promise<Bool>\r\n\t{\r\n\t\tvar def = new Deferred<Bool>();\r\n\t\tvar pr = def.promise();\r\n\t\tvar done = function() { if (!pr.isFulfilled()) def.resolve(true); };\r\n\r\n\t\t#if neko\r\n\t\tThread.create(function() {\r\n\t\t\tSys.sleep(ms / 1000);\r\n\t\t\tdone();\r\n\t\t});\r\n\t\t#elseif (js || flash)\r\n\t\tTimer.delay(function() { done(); }, ms);\r\n\t\t#elseif cs\r\n\t\tvar t = new Timer(ms);\r\n\t\tt.add_Elapsed(new ElapsedEventHandler(function(sender : Dynamic, e : ElapsedEventArgs) {\r\n\t\t\tt.Stop(); t = null;\r\n\t\t\tdone();\r\n\t\t}));\r\n\t\tt.Start();\r\n\t\t#elseif java\r\n\t\tvar executor = Executors.newFixedThreadPool(1);\r\n\t\tvar call = new AsyncCallable(function() {\r\n\t\t\texecutor.shutdown(); executor = null;\r\n\t\t\tdone();\r\n\t\t}, ms);\r\n\t\texecutor.execute(new FutureTask(call));\r\n\t\t#elseif cpp\r\n\t\tThread.create(function() {\r\n\t\t\tSys.sleep(ms / 1000);\r\n\t\t\tdone();\r\n\t\t});\r\n\t\t#elseif php\r\n\t\tthrow \"AsyncTools.wait not supported for PHP.\";\r\n\t\t#else\r\n\t\tSys.sleep(ms / 1000);\r\n\t\tdone();\r\n\t\t#end\r\n\r\n\t\treturn pr;\r\n\t}\r\n\r\n\tprivate static function next<T, T2>(it : Iterator<T>, action : T -> Promise<T>, def : Deferred<T2>, resolveWith : T2)\r\n\t{\r\n\t\t/*\r\n\t\ttrace(\"Next\");\r\n\t\ttrace(Type.getClassName(Type.getClass(resolveWith)));\r\n\t\ttrace(resolveWith);\r\n\t\ttrace(\"==============\");\r\n\t\t*/\r\n\r\n\t\tif (!it.hasNext())\r\n\t\t{\r\n\t\t\t//trace(\"Iterator empty\");\r\n\t\t\tdef.resolve(resolveWith);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tvar n = it.next();\r\n\t\t\t//trace(\"Iterating \" + Type.getClassName(Type.getClass(n)));\r\n\t\t\taction(n).then(function(_) { next(it, action, def, resolveWith); } );\r\n\t\t}\r\n\t}\r\n}\r\n\r\n#if java\r\nprivate class AsyncCallable implements Callable<String>\r\n{\r\n\tprivate var done : Void -> Void;\r\n\tprivate var waitMs : Int;\r\n\r\n\tpublic function new(done : Void -> Void, waitMs : Int)\r\n\t{\r\n\t\tthis.done = done;\r\n\t\tthis.waitMs = waitMs;\r\n\t}\r\n\r\n\tpublic function call() : String\r\n\t{\r\n\t\tSys.sleep(waitMs / 1000);\r\n\t\tdone();\r\n\t\treturn \"\";\r\n\t}\r\n}\r\n#end","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe;\n\n/**\n\tElements return by `CallStack` methods.\n**/\nenum StackItem {\n\tCFunction;\n\tModule( m : String );\n\tFilePos( s : Null<StackItem>, file : String, line : Int );\n\tMethod( classname : String, method : String );\n\tLocalFunction( v : Int );\n}\n\n/**\n\tGet informations about the call stack.\n**/\nclass CallStack {\n\n\t/**\n\t\tReturn the call stack elements, or an empty array if not available.\n\t**/\n\tpublic static function callStack() : Array<StackItem> {\n\t\t#if neko\n\t\t\tvar a = makeStack(untyped __dollar__callstack());\n\t\t\ta.shift(); // remove Stack.callStack()\n\t\t\treturn a;\n\t\t#elseif flash9\n\t\t\tvar a = makeStack( new flash.errors.Error().getStackTrace() );\n\t\t\ta.shift(); // remove Stack.callStack()\n\t\t\treturn a;\n\t\t#elseif flash\n\t\t\treturn makeStack(\"$s\");\n\t\t#elseif php\n\t\t\treturn makeStack(\"%s\");\n\t\t#elseif cpp\n\t\t\tvar s:Array<String> = untyped __global__.__hxcpp_get_call_stack(true);\n\t\t\treturn makeStack(s);\n\t\t#elseif js\n\t\t\t// https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi\n\t\t\tvar oldValue = (untyped Error).prepareStackTrace;\n\t\t\t(untyped Error).prepareStackTrace = function (error, callsites :Array<Dynamic>) {\n\t\t\t\tvar stack = [];\n\t\t\t\tfor (site in callsites) {\n\t\t\t\t\tvar method = null;\n\t\t\t\t\tvar fullName :String = site.getFunctionName();\n\t\t\t\t\tif (fullName != null) {\n\t\t\t\t\t\tvar idx = fullName.lastIndexOf(\".\");\n\t\t\t\t\t\tif (idx >= 0) {\n\t\t\t\t\t\t\tvar className = fullName.substr(0, idx);\n\t\t\t\t\t\t\tvar methodName = fullName.substr(idx+1);\n\t\t\t\t\t\t\tmethod = Method(className, methodName);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tstack.push(FilePos(method, site.getFileName(), site.getLineNumber()));\n\t\t\t\t}\n\t\t\t\treturn stack;\n\t\t\t}\n\t\t\tvar a = makeStack(untyped __new__(\"Error\").stack);\n\t\t\ta.shift(); // remove Stack.callStack()\n\t\t\t(untyped Error).prepareStackTrace = oldValue;\n\t\t\treturn a;\n\t\t#elseif java\n\t\t\tvar stack = [];\n\t\t\tfor ( el in java.lang.Thread.currentThread().getStackTrace() ) {\n\t\t\t\tvar className = el.getClassName();\n\t\t\t\tvar methodName = el.getMethodName();\n\t\t\t\tvar fileName = el.getFileName();\n\t\t\t\tvar lineNumber = el.getLineNumber();\n\t\t\t\tvar method = Method( className, methodName );\n\t\t\t\tif ( fileName != null || lineNumber >= 0 ) {\n\t\t\t\t\tstack.push( FilePos( method, fileName, lineNumber ) );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstack.push( method );\n\t\t\t\t}\n\t\t\t}\n\t\t\tstack.shift();\n\t\t\tstack.shift();\n\t\t\tstack.pop();\n\t\t\treturn stack;\n\t\t#elseif cs\n\t\t\treturn makeStack(new cs.system.diagnostics.StackTrace(1, true));\n\t\t#else\n\t\t\treturn []; // Unsupported\n\t\t#end\n\t}\n\n\t/**\n\t\tReturn the exception stack : this is the stack elements between\n\t\tthe place the last exception was thrown and the place it was\n\t\tcaught, or an empty array if not available.\n\t**/\n\t#if cpp @:noStack #end /* Do not mess up the exception stack */\n\tpublic static function exceptionStack() : Array<StackItem> {\n\t\t#if neko\n\t\t\treturn makeStack(untyped __dollar__excstack());\n\t\t#elseif as3\n\t\t\treturn new Array();\n\t\t#elseif flash9\n\t\t\tvar err : flash.errors.Error = untyped flash.Boot.lastError;\n\t\t\tif( err == null ) return new Array();\n\t\t\tvar a = makeStack( err.getStackTrace() );\n\t\t\tvar c = callStack();\n\t\t\tvar i = c.length - 1;\n\t\t\twhile( i > 0 ) {\n\t\t\t\tif( Std.string(a[a.length-1]) == Std.string(c[i]) )\n\t\t\t\t\ta.pop();\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t\ti--;\n\t\t\t}\n\t\t\treturn a;\n\t\t#elseif flash\n\t\t\treturn makeStack(\"$e\");\n\t\t#elseif php\n\t\t\treturn makeStack(\"%e\");\n\t\t#elseif cpp\n\t\t\tvar s:Array<String> = untyped __global__.__hxcpp_get_exception_stack();\n\t\t\treturn makeStack(s);\n\t\t#elseif java\n\t\t\tvar stack = [];\n\t\t\tfor ( el in java.internal.Exceptions.currentException().getStackTrace() ) {\n\t\t\t\tvar className = el.getClassName();\n\t\t\t\tvar methodName = el.getMethodName();\n\t\t\t\tvar fileName = el.getFileName();\n\t\t\t\tvar lineNumber = el.getLineNumber();\n\t\t\t\tvar method = Method( className, methodName );\n\t\t\t\tif ( fileName != null || lineNumber >= 0 ) {\n\t\t\t\t\tstack.push( FilePos( method, fileName, lineNumber ) );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstack.push( method );\n\t\t\t\t}\n\t\t\t}\n\t\t\t// stack.shift();\n\t\t\tstack.shift();\n\t\t\tstack.pop();\n\t\t\treturn stack;\n\t\t#elseif cs\n\t\t\treturn makeStack(new cs.system.diagnostics.StackTrace(cs.internal.Exceptions.exception, true));\n\t\t#else\n\t\t\treturn []; // Unsupported\n\t\t#end\n\t}\n\n\t/**\n\t\tReturns a representation of the stack as a printable string.\n\t**/\n\tpublic static function toString( stack : Array<StackItem> ) {\n\t\tvar b = new StringBuf();\n\t\tfor( s in stack ) {\n\t\t\tb.add(\"\\nCalled from \");\n\t\t\titemToString(b,s);\n\t\t}\n\t\treturn b.toString();\n\t}\n\n\tprivate static function itemToString( b : StringBuf, s ) {\n\t\tswitch( s ) {\n\t\tcase CFunction:\n\t\t\tb.add(\"a C function\");\n\t\tcase Module(m):\n\t\t\tb.add(\"module \");\n\t\t\tb.add(m);\n\t\tcase FilePos(s,file,line):\n\t\t\tif( s != null ) {\n\t\t\t\titemToString(b,s);\n\t\t\t\tb.add(\" (\");\n\t\t\t}\n\t\t\tb.add(file);\n\t\t\tb.add(\" line \");\n\t\t\tb.add(line);\n\t\t\tif( s != null ) b.add(\")\");\n\t\tcase Method(cname,meth):\n\t\t\tb.add(cname);\n\t\t\tb.add(\".\");\n\t\t\tb.add(meth);\n\t\tcase LocalFunction(n):\n\t\t\tb.add(\"local function #\");\n\t\t\tb.add(n);\n\t\t}\n\t}\n\n\t#if cpp @:noStack #end /* Do not mess up the exception stack */\n\tprivate static function makeStack(s #if cs : cs.system.diagnostics.StackTrace #end) {\n\t\t#if neko\n\t\t\tvar a = new Array();\n\t\t\tvar l = untyped __dollar__asize(s);\n\t\t\tvar i = 0;\n\t\t\twhile( i < l ) {\n\t\t\t\tvar x = s[i++];\n\t\t\t\tif( x == null )\n\t\t\t\t\ta.unshift(CFunction);\n\t\t\t\telse if( untyped __dollar__typeof(x) == __dollar__tstring )\n\t\t\t\t\ta.unshift(Module(new String(x)));\n\t\t\t\telse\n\t\t\t\t\ta.unshift(FilePos(null,new String(untyped x[0]),untyped x[1]));\n\t\t\t}\n\t\t\treturn a;\n\t\t#elseif flash9\n\t\t\tvar a = new Array();\n\t\t\tvar r = ~/at ([^\\/]+?)\\$?(\\/[^\\(]+)?\\(\\)(\\[(.*?):([0-9]+)\\])?/;\n\t\t\tvar rlambda = ~/^MethodInfo-([0-9]+)$/g;\n\t\t\twhile( r.match(s) ) {\n\t\t\t\tvar cl = r.matched(1).split(\"::\").join(\".\");\n\t\t\t\tvar meth = r.matched(2);\n\t\t\t\tvar item;\n\t\t\t\tif( meth == null ) {\n\t\t\t\t\tif( rlambda.match(cl) )\n\t\t\t\t\t\titem = LocalFunction(Std.parseInt(rlambda.matched(1)));\n\t\t\t\t\telse\n\t\t\t\t\t\titem = Method(cl,\"new\");\n\t\t\t\t} else\n\t\t\t\t\titem = Method(cl,meth.substr(1));\n\t\t\t\tif( r.matched(3) != null )\n\t\t\t\t\titem = FilePos( item, r.matched(4), Std.parseInt(r.matched(5)) );\n\t\t\t\ta.push(item);\n\t\t\t\ts = r.matchedRight();\n\t\t\t}\n\t\t\treturn a;\n\t\t#elseif flash\n\t\t\tvar a : Array<String> = untyped __eval__(s);\n\t\t\tvar m = new Array();\n\t\t\tfor( i in 0...a.length - if(s == \"$s\") 2 else 0 ) {\n\t\t\t\tvar d = a[i].split(\"::\");\n\t\t\t\tm.unshift(Method(d[0],d[1]));\n\t\t\t}\n\t\t\treturn m;\n\t\t#elseif php\n\t\t\tif (!untyped __call__(\"isset\", __var__(\"GLOBALS\", s)))\n\t\t\t\treturn [];\n\t\t\tvar a : Array<String> = untyped __var__(\"GLOBALS\", s);\n\t\t\tvar m = [];\n\t\t\tfor( i in 0...a.length - ((s == \"%s\") ? 2 : 0)) {\n\t\t\t\tvar d = a[i].split(\"::\");\n\t\t\t\tm.unshift(Method(d[0],d[1]));\n\t\t\t}\n\t\t\treturn m;\n\t\t#elseif cpp\n\t\t\tvar stack : Array<String> = s;\n\t\t\tvar m = new Array<StackItem>();\n\t\t\tfor(func in stack) {\n\t\t\t\tvar words = func.split(\"::\");\n\t\t\t\tif (words.length==0)\n\t\t\t\t\tm.unshift(CFunction)\n\t\t\t\telse if (words.length==2)\n\t\t\t\t\tm.unshift(Method(words[0],words[1]));\n\t\t\t\telse if (words.length==4)\n\t\t\t\t\tm.unshift(FilePos( Method(words[0],words[1]),words[2],Std.parseInt(words[3])));\n\t\t\t}\n\t\t\treturn m;\n\t\t#elseif js\n\t\t\tif ((untyped __js__(\"typeof\"))(s) == \"string\") {\n\t\t\t\t// Return the raw lines in browsers that don't support prepareStackTrace\n\t\t\t\tvar stack : Array<String> = s.split(\"\\n\");\n\t\t\t\tvar m = [];\n\t\t\t\tfor( line in stack ) {\n\t\t\t\t\tm.push(Module(line)); // A little weird, but better than nothing\n\t\t\t\t}\n\t\t\t\treturn m;\n\t\t\t} else {\n\t\t\t\treturn cast s;\n\t\t\t}\n\t\t#elseif cs\n\t\t\tvar stack = [];\n\t\t\tfor (i in 0...s.FrameCount)\n\t\t\t{\n\t\t\t\tvar frame = s.GetFrame(i);\n\t\t\t\tvar m = frame.GetMethod();\n\n\t\t\t\tvar method = StackItem.Method(m.ReflectedType.ToString(), m.Name);\n\n\t\t\t\tvar fileName = frame.GetFileName();\n\t\t\t\tvar lineNumber = frame.GetFileLineNumber();\n\n\t\t\t\tif (fileName != null || lineNumber >= 0)\n\t\t\t\t\tstack.push(FilePos(method, fileName, lineNumber));\n\t\t\t\telse\n\t\t\t\t\tstack.push(method);\n\t\t\t}\n\t\t\treturn stack;\n\t\t#else\n\t\t\treturn null;\n\t\t#end\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe;\n\n/**\n\tLog primarily provides the trace() method, which is invoked upon a call to\n\ttrace() in haxe code.\n**/\nclass Log {\n\n\t/**\n\t\tOutputs `v` in a platform-dependent way.\n\n\t\tThe second parameter `infos` is injected by the compiler and contains\n\t\tinformation about the position where the trace() call was made.\n\n\t\tThis method can be rebound to a custom function:\n\t\t\tvar oldTrace = haxe.Log.trace; // store old function\n\t\t\thaxe.Log.trace = function(v,infos) { // handle trace }\n\t\t\t...\n\t\t\thaxe.Log.trace = oldTrace;\n\n\t\tIf it is bound to null, subsequent calls to trace() will cause an\n\t\texception.\n\t**/\n\tpublic static dynamic function trace( v : Dynamic, ?infos : PosInfos ) : Void {\n\t\t#if flash\n\t\t\t#if (fdb || native_trace)\n\t\t\t\tvar pstr = infos == null ? \"(null)\" : infos.fileName + \":\" + infos.lineNumber;\n\t\t\t\tvar str = flash.Boot.__string_rec(v, \"\");\n\t\t\t\tif( infos != null && infos.customParams != null ) for( v in infos.customParams ) str += \",\" + flash.Boot.__string_rec(v, \"\");\n\t\t\t\tuntyped #if flash9 __global__[\"trace\"] #else __trace__ #end(pstr+\": \"+str);\n\t\t\t#else\n\t\t\t\tuntyped flash.Boot.__trace(v,infos);\n\t\t\t#end\n\t\t#elseif neko\n\t\t\tuntyped {\n\t\t\t\t$print(infos.fileName + \":\" + infos.lineNumber + \": \", v);\n\t\t\t\tif( infos.customParams != null ) for( v in infos.customParams ) $print(\",\", v);\n\t\t\t\t$print(\"\\n\");\n\t\t\t}\n\t\t#elseif js\n\t\t\tuntyped js.Boot.__trace(v,infos);\n\t\t#elseif php\n\t\t\tif (infos!=null && infos.customParams!=null) {\n\t\t\t\tvar extra:String = \"\";\n\t\t\t\tfor( v in infos.customParams )\n\t\t\t\t\textra += \",\" + v;\n\t\t\t\tuntyped __call__('_hx_trace', v + extra, infos);\n\t\t\t}\n\t\t\telse\n\t\t\t\tuntyped __call__('_hx_trace', v, infos);\n\t\t#elseif cpp\n\t\t\tif (infos!=null && infos.customParams!=null) {\n\t\t\t\tvar extra:String = \"\";\n\t\t\t\tfor( v in infos.customParams )\n\t\t\t\t\textra += \",\" + v;\n\t\t\t\tuntyped __trace(v + extra,infos);\n\t\t\t}\n\t\t\telse\n\t\t\t\tuntyped __trace(v,infos);\n\t\t#elseif (cs || java)\n\t\t\tvar str:String = null;\n\t\t\tif (infos != null) {\n\t\t\t\tstr = infos.fileName + \":\" + infos.lineNumber + \": \" + v;\n\t\t\t\tif (infos.customParams != null)\n\t\t\t\t{\n\t\t\t\t\tstr += \",\" + infos.customParams.join(\",\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstr = v;\n\t\t\t}\n\t\t\t#if cs\n\t\t\tcs.system.Console.WriteLine(str);\n\t\t\t#elseif java\n\t\t\tuntyped __java__(\"java.lang.System.out.println(str)\");\n\t\t\t#end\n\t\t#end\n\t}\n\n\t#if (flash || js)\n\t/**\n\t\tClears the trace output.\n\t**/\n\tpublic static dynamic function clear() : Void {\n\t\t#if flash\n\t\tuntyped flash.Boot.__clear_trace();\n\t\t#elseif js\n\t\tuntyped js.Boot.__clear_trace();\n\t\t#end\n\t}\n\t#end\n\n\t#if flash\n\t/**\n\t\tSets the color of the trace output to `rgb`.\n\t**/\n\tpublic static dynamic function setColor( rgb : Int ) {\n\t\tuntyped flash.Boot.__set_trace_color(rgb);\n\t}\n\t#end\n\n}\n","/*\n * Copyright (C)2005-2013 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe;\n\n/**\n\tThe Timer class allows you to create asynchronous timers on platforms that\n\tsupport events.\n\n\tThe intended usage is to create an instance of the Timer class with a given\n\tinterval, set its run() method to a custom function to be invoked and\n\teventually call stop() to stop the Timer.\n\n\tNote that a running Timer may or may not prevent the program to exit\n\tautomatically when main() returns.\n\n\tIt is also possible to extend this class and override its run() method in\n\tthe child class.\n**/\nclass Timer {\n\t#if (flash || js || java)\n\n\t#if (flash || js)\n\t\tprivate var id : Null<Int>;\n\t#elseif java\n\t\tprivate var timer : java.util.Timer;\n\t\tprivate var task : java.util.TimerTask;\n\t#end\n\n\t/**\n\t\tCreates a new timer that will run every `time_ms` milliseconds.\n\n\t\tAfter creating the Timer instance, it calls `this].run` repeatedly,\n\t\twith delays of `time_ms` milliseconds, until `this.stop` is called.\n\n\t\tThe first invocation occurs after `time_ms` milliseconds, not\n\t\timmediately.\n\n\t\tThe accuracy of this may be platform-dependent.\n\t**/\n\tpublic function new( time_ms : Int ){\n\t\t#if flash9\n\t\t\tvar me = this;\n\t\t\tid = untyped __global__[\"flash.utils.setInterval\"](function() { me.run(); },time_ms);\n\t\t#elseif flash\n\t\t\tvar me = this;\n\t\t\tid = untyped _global[\"setInterval\"](function() { me.run(); },time_ms);\n\t\t#elseif js\n\t\t\tvar me = this;\n\t\t\tid = untyped setInterval(function() me.run(),time_ms);\n\t\t#elseif java\n\t\t\ttimer = new java.util.Timer();\n\t\t\ttimer.scheduleAtFixedRate(task = new TimerTask(this), haxe.Int64.ofInt(time_ms), haxe.Int64.ofInt(time_ms));\n\t\t#end\n\t}\n\n\t/**\n\t\tStops `this` Timer.\n\n\t\tAfter calling this method, no additional invocations of `this.run`\n\t\twill occur.\n\n\t\tIt is not possible to restart `this` Timer once stopped.\n\t**/\n\tpublic function stop() {\n\t\t#if (flash || js)\n\t\t\tif( id == null )\n\t\t\t\treturn;\n\t\t\t#if flash9\n\t\t\t\tuntyped __global__[\"flash.utils.clearInterval\"](id);\n\t\t\t#elseif flash\n\t\t\t\tuntyped _global[\"clearInterval\"](id);\n\t\t\t#elseif js\n\t\t\t\tuntyped clearInterval(id);\n\t\t\t#end\n\t\t\tid = null;\n\t\t#elseif java\n\t\t\ttimer.cancel();\n\t\t\ttimer = null;\n\t\t\ttask = null;\n\t\t#end\n\t}\n\n\t/**\n\t\tThis method is invoked repeatedly on `this` Timer.\n\n\t\tIt can be overridden in a subclass, or rebound directly to a custom\n\t\tfunction:\n\t\t\tvar timer = new haxe.Timer(1000); // 1000ms delay\n\t\t\ttimer.run = function() { ... }\n\n\t\tOnce bound, it can still be rebound to different functions until `this`\n\t\tTimer is stopped through a call to `this.stop`.\n\t**/\n\tpublic dynamic function run() {\n\n\t}\n\n\t/**\n\t\tInvokes `f` after `time_ms` milliseconds.\n\n\t\tThis is a convenience function for creating a new Timer instance with\n\t\t`time_ms` as argument, binding its run() method to `f` and then stopping\n\t\t`this` Timer upon the first invocation.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function delay( f : Void -> Void, time_ms : Int ) {\n\t\tvar t = new haxe.Timer(time_ms);\n\t\tt.run = function() {\n\t\t\tt.stop();\n\t\t\tf();\n\t\t};\n\t\treturn t;\n\t}\n\n\t#end\n\n\t/**\n\t\tMeasures the time it takes to execute `f`, in seconds with fractions.\n\n\t\tThis is a convenience function for calculating the difference between\n\t\tTimer.stamp() before and after the invocation of `f`.\n\n\t\tThe difference is passed as argument to Log.trace(), with \"s\" appended\n\t\tto denote the unit. The optional `pos` argument is passed through.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function measure<T>( f : Void -> T, ?pos : PosInfos ) : T {\n\t\tvar t0 = stamp();\n\t\tvar r = f();\n\t\tLog.trace((stamp() - t0) + \"s\", pos);\n\t\treturn r;\n\t}\n\n\t/**\n\t\tReturns a timestamp, in seconds with fractions.\n\n\t\tThe value itself might differ depending on platforms, only differences\n\t\tbetween two values make sense.\n\t**/\n\tpublic static function stamp() : Float {\n\t\t#if flash\n\t\t\treturn flash.Lib.getTimer() / 1000;\n\t\t#elseif (neko || php)\n\t\t\treturn Sys.time();\n\t\t#elseif js\n\t\t\treturn Date.now().getTime() / 1000;\n\t\t#elseif cpp\n\t\t\treturn untyped __global__.__time_stamp();\n\t\t#elseif sys\n\t\t\treturn Sys.time();\n\t\t#else\n\t\t\treturn 0;\n\t\t#end\n\t}\n\n}\n\n#if java\n@:nativeGen\nprivate class TimerTask extends java.util.TimerTask {\n\tvar timer:Timer;\n\tpublic function new(timer:Timer):Void {\n\t\tsuper();\n\t\tthis.timer = timer;\n\t}\n\n\t@:overload public function run():Void {\n\t\ttimer.run();\n\t}\n}\n#end","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe.rtti;\n\n/**\n\tAn api to access classes and enums metadata at runtime.\n**/\nclass Meta {\n\n\t/**\n\t\tReturns the metadata that were declared for the given type (class or enum)\n\t**/\n\tpublic static function getType( t : Dynamic ) : Dynamic<Array<Dynamic>> {\n\t\t#if (java || cs)\n\t\tvar meta : Dynamic = Reflect.field(t, \"__meta__\");\n\t\t#else\n\t\tvar meta : Dynamic = untyped t.__meta__;\n\t\t#end\n\t\treturn (meta == null || meta.obj == null) ? {} : meta.obj;\n\t}\n\n\t/**\n\t\tReturns the metadata that were declared for the given class static fields\n\t**/\n\tpublic static function getStatics( t : Dynamic ) : Dynamic<Dynamic<Array<Dynamic>>> {\n\t\t#if (java || cs)\n\t\tvar meta : Dynamic = Reflect.field(t, \"__meta__\");\n\t\t#else\n\t\tvar meta : Dynamic = untyped t.__meta__;\n\t\t#end\n\t\treturn (meta == null || meta.statics == null) ? {} : meta.statics;\n\t}\n\n\t/**\n\t\tReturns the metadata that were declared for the given class fields or enum constructors\n\t**/\n\tpublic static function getFields( t : Dynamic ) : Dynamic<Dynamic<Array<Dynamic>>> {\n\t\t#if (java || cs)\n\t\tvar meta : Dynamic = Reflect.field(t, \"__meta__\");\n\t\t#else\n\t\tvar meta : Dynamic = untyped t.__meta__;\n\t\t#end\n\t\treturn (meta == null || meta.fields == null) ? {} : meta.fields;\n\t}\n\n}","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage js;\n\nclass Boot {\n\n\tprivate static function __unhtml(s : String) {\n\t\treturn s.split(\"&\").join(\"&amp;\").split(\"<\").join(\"&lt;\").split(\">\").join(\"&gt;\");\n\t}\n\n\tprivate static function __trace(v,i : haxe.PosInfos) {\n\t\tuntyped {\n\t\t\tvar msg = if( i != null ) i.fileName+\":\"+i.lineNumber+\": \" else \"\";\n\t\t\t#if jsfl\n\t\t\tmsg += __string_rec(v,\"\");\n\t\t\tfl.trace(msg);\n\t\t\t#else\n\t\t\tmsg += __string_rec(v, \"\");\n\t\t\tif( i != null && i.customParams != null )\n\t\t\t\tfor( v in i.customParams )\n\t\t\t\t\tmsg += \",\" + __string_rec(v, \"\");\n\t\t\tvar d;\n\t\t\tif( __js__(\"typeof\")(document) != \"undefined\" && (d = document.getElementById(\"haxe:trace\")) != null )\n\t\t\t\td.innerHTML += __unhtml(msg)+\"<br/>\";\n\t\t\telse if( __js__(\"typeof console\") != \"undefined\" && __js__(\"console\").log != null )\n\t\t\t\t__js__(\"console\").log(msg);\n\t\t\t#end\n\t\t}\n\t}\n\n\tprivate static function __clear_trace() {\n\t\tuntyped {\n\t\t\t#if jsfl\n\t\t\tfl.outputPanel.clear();\n\t\t\t#else\n\t\t\tvar d = document.getElementById(\"haxe:trace\");\n\t\t\tif( d != null )\n\t\t\t\td.innerHTML = \"\";\n\t\t\t#end\n\t\t}\n\t}\n\n\tstatic inline function isClass(o:Dynamic) : Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isClass\", o.__name__);\n\t}\n\n\tstatic inline function isEnum(e:Dynamic) : Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isEnum\", e.__ename__);\n\t}\n\n\tstatic inline function getClass(o:Dynamic) : Dynamic {\n\t\tif (Std.is(o, Array))\n\t\t\treturn Array;\n\t\telse\n\t\t\treturn untyped __define_feature__(\"js.Boot.getClass\", o.__class__);\n\t}\n\n\t@:ifFeature(\"may_print_enum\")\n\tprivate static function __string_rec(o,s:String) {\n\t\tuntyped {\n\t\t\tif( o == null )\n\t\t\t    return \"null\";\n\t\t\tif( s.length >= 5 )\n\t\t\t\treturn \"<...>\"; // too much deep recursion\n\t\t\tvar t = __js__(\"typeof(o)\");\n\t\t\tif( t == \"function\" && (isClass(o) || isEnum(o)) )\n\t\t\t\tt = \"object\";\n\t\t\tswitch( t ) {\n\t\t\tcase \"object\":\n\t\t\t\tif( __js__(\"o instanceof Array\") ) {\n\t\t\t\t\tif( o.__enum__ ) {\n\t\t\t\t\t\tif( o.length == 2 )\n\t\t\t\t\t\t\treturn o[0];\n\t\t\t\t\t\tvar str = o[0]+\"(\";\n\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\tfor( i in 2...o.length ) {\n\t\t\t\t\t\t\tif( i != 2 )\n\t\t\t\t\t\t\t\tstr += \",\" + __string_rec(o[i],s);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tstr += __string_rec(o[i],s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn str + \")\";\n\t\t\t\t\t}\n\t\t\t\t\tvar l = o.length;\n\t\t\t\t\tvar i;\n\t\t\t\t\tvar str = \"[\";\n\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\tfor( i in 0...l )\n\t\t\t\t\t\tstr += (if (i > 0) \",\" else \"\")+__string_rec(o[i],s);\n\t\t\t\t\tstr += \"]\";\n\t\t\t\t\treturn str;\n\t\t\t\t}\n\t\t\t\tvar tostr;\n\t\t\t\ttry {\n\t\t\t\t\ttostr = untyped o.toString;\n\t\t\t\t} catch( e : Dynamic ) {\n\t\t\t\t\t// strange error on IE\n\t\t\t\t\treturn \"???\";\n\t\t\t\t}\n\t\t\t\tif( tostr != null && tostr != __js__(\"Object.toString\") ) {\n\t\t\t\t\tvar s2 = o.toString();\n\t\t\t\t\tif( s2 != \"[object Object]\")\n\t\t\t\t\t\treturn s2;\n\t\t\t\t}\n\t\t\t\tvar k : String = null;\n\t\t\t\tvar str = \"{\\n\";\n\t\t\t\ts += \"\\t\";\n\t\t\t\tvar hasp = (o.hasOwnProperty != null);\n\t\t\t\t__js__(\"for( var k in o ) {\");\n\t\t\t\t\tif( hasp && !o.hasOwnProperty(k) )\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif( k == \"prototype\" || k == \"__class__\" || k == \"__super__\" || k == \"__interfaces__\" || k == \"__properties__\" )\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif( str.length != 2 )\n\t\t\t\t\t\tstr += \", \\n\";\n\t\t\t\t\tstr += s + k + \" : \"+__string_rec(o[k],s);\n\t\t\t\t__js__(\"}\");\n\t\t\t\ts = s.substring(1);\n\t\t\t\tstr += \"\\n\" + s + \"}\";\n\t\t\t\treturn str;\n\t\t\tcase \"function\":\n\t\t\t\treturn \"<function>\";\n\t\t\tcase \"string\":\n\t\t\t\treturn o;\n\t\t\tdefault:\n\t\t\t\treturn String(o);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static function __interfLoop(cc : Dynamic,cl : Dynamic) {\n\t\tif( cc == null )\n\t\t\treturn false;\n\t\tif( cc == cl )\n\t\t\treturn true;\n\t\tvar intf : Dynamic = cc.__interfaces__;\n\t\tif( intf != null )\n\t\t\tfor( i in 0...intf.length ) {\n\t\t\t\tvar i : Dynamic = intf[i];\n\t\t\t\tif( i == cl || __interfLoop(i,cl) )\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\treturn __interfLoop(cc.__super__,cl);\n\t}\n\n\t@:ifFeature(\"typed_catch\") private static function __instanceof(o : Dynamic,cl : Dynamic) {\n\t\tif( cl == null )\n\t\t\treturn false;\n\t\tswitch( cl ) {\n\t\tcase Int:\n\t\t\treturn (untyped __js__(\"(o|0) === o\"));\n\t\tcase Float:\n\t\t\treturn (untyped __js__(\"typeof\"))(o) == \"number\";\n\t\tcase Bool:\n\t\t\treturn (untyped __js__(\"typeof\"))(o) == \"boolean\";\n\t\tcase String:\n\t\t\treturn (untyped __js__(\"typeof\"))(o) == \"string\";\n\t\tcase Array:\n\t\t\treturn (untyped __js__(\"(o instanceof Array)\")) && o.__enum__ == null;\n\t\tcase Dynamic:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\tif( o != null ) {\n\t\t\t\t// Check if o is an instance of a Haxe class\n\t\t\t\tif( (untyped __js__(\"typeof\"))(cl) == \"function\" ) {\n\t\t\t\t\tif( untyped __js__(\"o instanceof cl\") ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tif( __interfLoop(getClass(o),cl) )\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// do not use isClass/isEnum here\n\t\t\tuntyped __feature__(\"Class.*\",if( cl == Class && o.__name__ != null ) return true);\n\t\t\tuntyped __feature__(\"Enum.*\",if( cl == Enum && o.__ename__ != null ) return true);\n\t\t\treturn o.__enum__ == cl;\n\t\t}\n\t}\n\n\t@:ifFeature(\"typed_cast\") private static function __cast(o : Dynamic, t : Dynamic) {\n\t\tif (__instanceof(o, t)) return o;\n\t\telse throw \"Cannot cast \" +Std.string(o) + \" to \" +Std.string(t);\n\t}\n\n}\n","package promhx;\n\n@:expose\nclass Deferred<T> {\n    var _update : Array<{func: T->Dynamic, error: Dynamic->Void}>;\n\n    public function new(){\n        this._update = [];\n    }\n\n    /**\n      The public write interface\n     **/\n    public function resolve(val:T){\n        for (u in _update) {\n            if (u.error != null){\n                try u.func(val)\n                catch(e:Dynamic) {\n                }\n            } else {\n                u.func(val);\n            }\n        }\n    }\n\n    /**\n      Register callbacks directly to a Deferred instance. \n     **/\n    public function then<X>(func : T->X, ?error : Dynamic->Void){\n        _update.push({func : func, error: error});\n    }\n\n    /**\n      Returns a promise based on the current deferred instance\n     **/\n    public function promise(){\n        return new Promise(this);\n    }\n\n    /**\n      Returns a stream based on the current deferred instance\n     **/\n    public function stream(){\n        return new Stream(this);\n    }\n\n    /**\n      Returns a stream based on the current deferred instance\n     **/\n    public function publicStream(){\n        return new PublicStream(this);\n    }\n}\n","/**\n  This is a primitive asynchronous class, used as a base class for Promise and\n  Signal.\n **/\n\n\npackage promhx.base;\n\n#if macro\nimport haxe.macro.Expr;\nimport haxe.macro.Type;\nimport haxe.macro.Context;\n#end\nimport promhx.base.EventLoop;\nimport promhx.Thenable;\n\ntypedef AsyncLink<T> = {\n    async : AsyncBase<Dynamic>,\n    linkf : T->Void\n}\n\n\nclass AsyncBase<T>{\n#if debug\n    // add ids to the async instances so they are easier to track\n    static var id_ctr  = 0;\n    var id          : Int;\n#end\n    var _val        : T;\n    var _resolved   : Bool;\n    var _fulfilled  : Bool;\n    var _pending    : Bool;\n    var _update     : Array<AsyncLink<T>>;\n    var _error      : Array<Dynamic->Void>;\n    var _errorMap   : Dynamic->T;\n\n    /**\n      Constructor argument can take optional function argument, which adds\n      a callback to the error handler chain.\n     **/\n    public function new(?d:Deferred<T>) {\n#if debug id = id_ctr +=1; #end\n        if (d != null){ \n            d.then(handleResolve, handleError ); \n        }\n\n        _resolved   = false;\n        _pending = false;\n        _fulfilled  = false;\n        _update     = [];\n        _error      = [];\n\n    }\n\n    /**\n      Catch error, effectively halting the current update chain.\n      This will prevent downstream async objects from receiving \n      the error message.\n     **/\n    public function catchError(f : Dynamic->Void) : AsyncBase<T> {\n        _error.push(f);\n        return this;\n    }\n\n    /**\n      Map errors back to the expected type, and continue as normal.\n     **/\n    public function errorThen( f : Dynamic -> T){\n        _errorMap = f;\n        return this;\n    }\n\n    /**\n      Utility function to determine if a Promise value has been resolved.\n     **/\n    public inline function isResolved() : Bool\n        return _resolved;\n\n\n    /**\n      Utility function to determine if a Promise value has been rejected.\n     **/\n    public inline function isFulfilled(): Bool\n        return _fulfilled;\n\n    /**\n      Utility function to determine if a Promise value is pending operations\n      on the next loop.\n     **/\n    public inline function isPending() : Bool\n        return _pending;\n\n\n    function handleResolve(val:T) : Void {\n        _resolve(val);\n    }\n    /**\n      Resolves the given value for processing on any waiting functions.\n     **/\n    function _resolve(val : T) : Void {\n\n        // this async is pending an update on the next loop, move the\n        // resolve to the loop after that.\n        if (_pending){\n            EventLoop.enqueue(_resolve.bind(val));\n        } else {\n\n            // point of no return, this async has now been resolved at least once.\n            _resolved = true;\n\n            // we are now in the act of fulfilling the async... which\n            // involves waiting for the next enqueued loop\n            _pending = true;\n\n            // the loop handler, which may not even be used\n            EventLoop.enqueue(function(){\n                _val = val; // save the value\n                for (up in _update){\n#if PromhxExposeErrors\n                    up.linkf(val);\n#else\n                    try up.linkf(val)\n                catch (e:Dynamic) up.async.handleError(e);\n#end\n                }\n                _fulfilled = true; // we're in a fulfilled state\n                _pending = false; // we're done fulfilling for this resolve\n            });\n        }\n\n    }\n\n    /**\n      Handle errors\n     **/\n    function handleError(error : Dynamic) : Void {\n        var update_errors = function(e:Dynamic){\n            if (_error.length > 0) for (ef in _error) ef(e);\n            else if (_update.length > 0) for (up in _update) up.async.handleError(e);\n            else {\n#if (js && nodejs)\n                // Node sometimes doesn't produce helpful stack information on thrown errors.\n                trace('Call Stack: ' + haxe.CallStack.toString(haxe.CallStack.callStack()));\n#end\n                throw e;\n            }\n        }\n        EventLoop.enqueue(function(){\n            if (_errorMap != null){\n#if PromhxExposeErrors\n                this._resolve(_errorMap(error));\n            _resolve(_errorMap(error));\n#else\n                try this._resolve(_errorMap(error))\n                catch (e : Dynamic) update_errors(e);\n#end\n            } else {\n                update_errors(error);\n            }\n        });\n    }\n\n    /**\n      This function returns a new AsyncBase.  When this instance resolves,\n      it will resolve the new AsyncBase with the function callback argument.\n     **/\n    public function then<A>(f : T->A) : AsyncBase<A> {\n        var ret = new AsyncBase<A>();\n        link(this, ret, f);\n        return ret;\n    }\n\n    /**\n      Remove an Async that is updated from this Async.  This action is\n      performed on the next event loop.\n     **/\n    public function unlink( to : AsyncBase<Dynamic>) {\n        EventLoop.enqueue(function(){\n            _update =  _update.filter(function(x) return x.async != to);\n        });\n    }\n\n    /**\n      Determine if an Async is updated from this Async.\n     **/\n    public function isLinked( to : AsyncBase<Dynamic>) : Bool {\n        var updated = false;\n        for (u in _update) if (u.async == to) return true;\n        return updated;\n    }\n\n\n    /**\n      This is the base \"link\" method for wiring up the \"current\" async to\n      the \"next\" one via the transform defined by the f argument.\n     **/\n    inline public static function link<A,B>\n        (current : AsyncBase<A>, next: AsyncBase<B>, f : A->B) : Void\n    {\n        // the function wrapper for the callback, which will resolve the return\n        // if current is not resolved, or will resolve next loop, push to\n        // update queues.\n        current._update.push({\n            async : next,\n            linkf : function(x){\n                next.handleResolve(f(x));\n            }\n        });\n        immediateLinkUpdate(current, next, f);\n    }\n\n    static function immediateLinkUpdate<A,B>\n        (current : AsyncBase<A>, next : AsyncBase<B>, f : A->B) : Void\n    {\n        if (current.isResolved() && !current.isPending()){\n            // we can go ahead and resolve this.\n#if PromhxExposeErrors\n            next.handleResolve(f(current._val));\n#else\n            try next.handleResolve(f(current._val))\n            catch (e:Dynamic) next.handleError(e);\n#end\n        }\n\n    }\n\n    inline public static function linkAll<T>\n        (all : Iterable<AsyncBase<T>>, next: AsyncBase<Array<T>>) : Void\n    {\n        // a helper callback function.  This will be called for each Stream in\n        // the iterable argument.  The \"arr\" argument will be all of the Streams\n        // *except* the one currently resolving.  If there's only one Stream\n        // in the iterable, it will always resolve.\n        var cthen = function(arr:Array<AsyncBase<T>>, current:AsyncBase<T>,  v){\n            if (arr.length == 0 || AsyncBase.allFulfilled(arr)){\n                var vals = [for (a in all) a == current ? v : a._val];\n                next.handleResolve(vals);\n            }\n            return null;\n        };\n        for (a in all){\n            a._update.push({\n                async : next,\n                linkf: cthen.bind([for (a2 in all) if (a2 != a) a2], a, _)\n            });\n        }\n\n        if (AsyncBase.allFulfilled(all)) {\n            next.handleResolve([for (a in all) a._val]);\n        }\n    }\n\n    /**\n      Similar to the link function, except the [f] function must return an\n      AsyncBase instance.\n     **/\n    inline static public function pipeLink<A,B>\n        ( current : AsyncBase<A>, ret : AsyncBase<B>, f : A->AsyncBase<B> ) : Void\n    {\n        var linked = false;\n        var linkf = function(x){ // updates go to pipe function.\n                if (!linked){ // but only once\n                    linked = true; // the piped async doesn't actually respond to updates from current\n                    var pipe_ret = f(x); // it just needs to be created\n                    pipe_ret._update.push({  // and to be linked to ret\n                        async : ret, // errors go to ret\n                        linkf : ret.handleResolve // updates go directly to ret\n                    });\n                    immediateLinkUpdate(pipe_ret, ret, function(x) return x );\n                }\n            }\n\n        current._update.push({\n            async : ret, // errors go to ret\n            linkf : linkf\n        });\n\n        if (current.isResolved() && !current.isPending()){\n#if PromhxExposeErrors\n            linkf(current._val);\n#else\n            try linkf(current._val)\n            catch (e:Dynamic) ret.handleError(e);\n#end\n        }\n    }\n\n    /**\n      Utility function to determine if all Promise values are set.\n     **/\n    public static function allResolved\n        (as : Iterable<AsyncBase<Dynamic>>) : Bool\n    {\n        for (a in as) {\n            if (!a.isResolved()) return false;\n        }\n        return true;\n    }\n\n    /**\n      Utility function to determine if all Promise values are resolved and\n      are currently fulfilled (not in the process of fulfilling).\n     **/\n    static function allFulfilled\n        (as : Iterable<AsyncBase<Dynamic>>) : Bool\n    {\n        for (a in as) {\n            if (!a.isFulfilled()) return false;\n        }\n        return true;\n    }\n\n}\n","package promhx;\n\n#if macro\nimport haxe.macro.Expr;\nimport haxe.macro.Type;\nimport haxe.macro.Context;\n#end\nimport promhx.base.EventLoop;\nimport promhx.base.AsyncBase;\nimport promhx.error.PromiseError;\n\n@:expose\nclass Promise<T> extends AsyncBase<T>{\n    var _rejected   : Bool;\n    public function new(?d:Deferred<T>){\n        super(d);\n        _rejected = false;\n    }\n\n    /**\n      Macro method that binds the promise arguments to a single function\n      callback that is triggered when all promises are resolved.\n      Note: You may call this function on as many promise arguments as you\n      like.\n     **/\n    macro public static function when<T>( args : Array<ExprOf<Promise<Dynamic>>>) : Expr {\n\n        // a default position\n        var pos = Context.currentPos();\n\n        //the macro arguments translated to an array expression.\n        var eargs = {expr:EArrayDecl(args), pos:pos};\n\n        // An array of the resolved promise values\n        var epargs = [for (a in args) { expr: EField(a, \"_val\"), pos: pos}];\n\n        // the returned function that actually does the runtime work.\n        return macro {\n            // a function that accepts a variable argument function\n            var varargf = function(f){\n                // we wait on all of the promises with the iterable-based \"whenAll\"\n                // this will resolve an array, so we use pipe to ignore it, and set\n                // up a new promise for return.\n                // this new promise resolves via a macro-defined function expression\n                // on \"f\" that provides arity and types for the resolved promise values.\n                var ret = new Promise();\n                var arr : Array<Promise<Dynamic>> = $eargs;\n                var p = Promise.whenAll(arr);\n                p._update.push({\n                    async : ret,\n                    linkf : function(x) ret.handleResolve(f($a{epargs}))\n                });\n                return ret;\n            };\n\n            // return an anonymous object with the function definition for \"then\"\n            { then : varargf };\n        }\n    }\n\n    /**\n      Utility function to determine if a Promise value has been rejected.\n     **/\n    public inline function isRejected(): Bool {\n        return _rejected;\n    }\n\n    /**\n      Rejects the promise, throwing an error.\n     **/\n    public function reject(e : Dynamic): Void {\n        this._rejected = true;\n        handleError(e);\n    }\n\n    /**\n      Transforms an iterable of promises into a single promise which resolves\n      to an array of values.\n     **/\n    public static function whenAll<T>(itb : Iterable<Promise<T>>) : Promise<Array<T>> {\n        var ret : Promise<Array<T>> = new Promise();\n        AsyncBase.linkAll(itb, ret);\n        return ret;\n    }\n\n    /**\n      Resolves the given value for processing on any waiting functions.\n     **/\n    override function handleResolve(val : T): Void {\n        if (_resolved) {\n            var msg = \"Promise has already been resolved\";\n            throw(AlreadyResolved(msg));\n        }\n        _resolve(val);\n    }\n\n    /**\n      add a wait function directly to the Promise instance.\n     **/\n    override public function then<A>(f : T->A): Promise<A> {\n        var ret  = new Promise<A>();\n        AsyncBase.link(this, ret, f);\n        return ret;\n    }\n\n    override public function unlink( to : AsyncBase<Dynamic>) {\n        EventLoop.enqueue(function(){\n            if (!isFulfilled()) {\n                var msg = \"Downstream Promise is not fullfilled\";\n                handleError(DownstreamNotFullfilled(msg));\n            }\n            else{\n                _update =  _update.filter(function(x) return x.async != to);\n            }\n        });\n    }\n\n    public function pipe<A>(f : T->Promise<A>) : Promise<A> {\n        var ret = new Promise<A>();\n        AsyncBase.pipeLink(this, ret, f);\n        return ret;\n    }\n\n\n    /**\n      Converts any value to a resolved Promise\n     **/\n    public static function promise<T>(_val : T): Promise<T> {\n        var ret = new Promise<T>();\n        ret.handleResolve(_val);\n        return ret;\n    }\n}\n\n","package promhx;\n\n#if macro\nimport haxe.macro.Expr;\nimport haxe.macro.Type;\nimport haxe.macro.Context;\n#end\nimport promhx.base.EventLoop;\nimport promhx.base.AsyncBase;\nimport haxe.ds.Option;\n\n@:expose\nclass Stream<T> extends AsyncBase<T> {\n    var deferred : Deferred<T>;\n    var _pause : Bool;\n    var _end : Bool;\n    var _end_promise : Promise<Option<T>>;\n    var _end_deferred : Deferred<Option<T>>;\n\n    public function new(?d : Deferred<T>){\n        super(d);\n        _end_deferred = new Deferred<Option<T>>();\n        _end_promise = _end_deferred.promise();\n    }\n\n    /**\n      Macro method that binds the stream arguments to a single function\n      callback that is triggered when all streams are updated.\n      Note: You may call this function on as many stream arguments as you\n      like.\n     **/\n    macro public static function whenever<T>( args : Array<ExprOf<AsyncBase<Dynamic>>>) : Expr {\n\n        // a default position\n        var pos = Context.currentPos();\n\n        //the macro arguments translated to an array expression.\n        var eargs = {expr:EArrayDecl(args), pos:pos};\n\n        // An array of the resolved stream values\n        var epargs = [for (a in args) { expr: EField(a, \"_val\"), pos: pos}];\n\n        // the returned function that actually does the runtime work.\n        return macro {\n            // a function that accepts a variable argument function\n            var varargf = function(f){\n                // we wait on all of the streams with the iterable-based \"whenAll\"\n                // this will resolve an array, so we use pipe to ignore it, and set\n                // up a new stream for return.\n                // this new stream resolves via a macro-defined function expression\n                // on \"f\" that provides arity and types for the resolved stream values.\n                var ret = new Stream();\n                var arr : Array<Stream<Dynamic>> = $eargs;\n                var p = Stream.wheneverAll(arr);\n                p._update.push({\n                    async: ret,\n                    linkf: function(x) ret.handleResolve(f($a{epargs}))\n                });\n                return ret;\n            };\n\n            // return an anonymous object with the function definition for \"then\"\n            { then : varargf };\n        }\n    }\n\n    /**\n      Creates a stream from the iterable [itb] that will immediately update\n      for each value, and then end.\n     **/\n    public static function foreach<T>(itb : Iterable<T>) : Stream<T> {\n        var s = new Stream<T>();\n        for (i in itb) s.handleResolve(i);\n        s.end();\n        return s;\n    }\n\n\n    /**\n      add a wait function directly to the Stream instance.\n     **/\n    override public function then<A>(f : T->A) : Stream<A> {\n        var ret  = new Stream<A>();\n        AsyncBase.link(this, ret, f);\n        _end_promise.then(function(x) ret.end());\n        return ret;\n    }\n\n    public function detachStream(str : Stream<Dynamic>) : Bool {\n        var filtered = [];\n        var removed = false;\n        for (u in this._update){\n            if (u.async == str)  removed = true;\n            else filtered.push(u);\n        }\n        this._update = filtered;\n        return removed;\n    }\n\n    /**\n      Transforms an iterable of streams into a single stream which resolves\n      to an array of values.\n     **/\n    public static function wheneverAll<T>(itb : Iterable<Stream<T>>) : Stream<Array<T>> {\n        var ret = new Stream<Array<T>>();\n        AsyncBase.linkAll(itb, ret);\n        return ret;\n    }\n\n    /**\n      Concatenates all the streams in the iterable argument to a single stream.  See\n      the [concat] instance method.\n     **/\n    public static function concatAll<T>(itb : Iterable<Stream<T>>) : Stream<T> {\n        var ret = new Stream<T>();\n        for (i in itb) ret.concat(i);\n        return ret;\n    }\n\n    /**\n      Merges all the streams in the iterable argument to a single stream.  See\n      the [merge] instance method.\n     **/\n    public static function mergeAll<T>(itb : Iterable<Stream<T>>) : Stream<T> {\n        var ret = new Stream<T>();\n        for (i in itb) ret.merge(i);\n        return ret;\n    }\n\n    /**\n      Returns a Promise that will resolve only for the first stream update.\n     **/\n    public inline function first() : Promise<T> {\n        var s = new Promise<T>();\n        this.then(function(x) if (!s.isResolved()) s.handleResolve(x));\n        return s;\n    }\n\n    override function handleResolve(val : T) : Void {\n        if (!_end && !_pause) _resolve(val);\n    }\n\n    /**\n      Momentarily disable updates for the stream.  Set the pause state with\n      the argument.  Call it without the argument to toggle the current state.\n     **/\n    public function pause(?set : Bool){\n        if (set == null) set == !_pause;\n        _pause = set;\n    }\n\n    public function pipe<A>(f : T->Stream<A>) : Stream<A> {\n        var ret = new Stream<A>();\n        AsyncBase.pipeLink(this, ret, f);\n        _end_promise.then(function(x) ret.end());\n        return ret;\n    }\n\n    /**\n      I need this as a private function to call recursively.\n     **/\n    function handleEnd(){\n        // If the async is still pending, check on the next loop.\n        if (this.isPending()) EventLoop.enqueue(handleEnd);\n        else if (_end_promise.isResolved()) return;\n        else {\n            _end = true;\n            var o = isResolved() ? Some(_val) : None;\n            _end_promise.handleResolve(o);\n            _update = [];\n            _error = [];\n        }\n    }\n\n    public function end(){\n        EventLoop.enqueue(handleEnd);\n        return this;\n    }\n\n    inline public function endThen<A>(f : Option<T>->A) : Promise<A>{\n       return _end_promise.then(f);\n    }\n\n    /**\n      Creates a new stream linked to the current instance that only updates\n      if the [f] argument is true.\n     **/\n    public function filter(f : T->Bool) : Stream<T>{\n        var ret = new Stream<T>();\n        _update.push({\n            async : ret,\n            linkf : function(x) if (f(x)) ret.handleResolve(x)\n        });\n        AsyncBase.immediateLinkUpdate(this, ret, function(x) return x);\n        return ret;\n    }\n\n    /**\n      Creates a new stream that updates with the values from the current\n      stream until the stream ends, and then takes values from the next stream\n      [s] until that stream ends.\n     **/\n    public function concat(s : Stream<T>) : Stream<T> {\n        var ret = new Stream<T>();\n        _update.push({\n            async : ret,\n            linkf : ret.handleResolve\n        });\n        AsyncBase.immediateLinkUpdate(this, ret, function(x) return x);\n        endThen(function(_){\n            s.pipe(function(x){\n                ret.handleResolve(x);\n                return ret;\n            });\n            s.endThen(function(_){\n                ret.end();\n            });\n        });\n        return ret;\n    }\n\n    /**\n      Merges another stream into the current one.\n     **/\n    public function merge(s : Stream<T>) : Stream<T> {\n        var ret = new Stream<T>();\n        _update.push({\n            async : ret,\n            linkf : ret.handleResolve\n        });\n        s._update.push({\n            async : ret,\n            linkf : ret.handleResolve\n        });\n        AsyncBase.immediateLinkUpdate(this, ret, function(x) return x);\n        AsyncBase.immediateLinkUpdate(s, ret, function(x) return x);\n        return ret;\n    }\n\n    /**\n      Converts any value to a resolved Stream\n     **/\n    public static function stream<A>(_val : A): Stream<A> {\n        var ret = new Stream<A>();\n        ret.handleResolve(_val);\n        return ret;\n    }\n\n}\n\n","\npackage promhx;\n\n@:expose\nclass PublicStream<T> extends Stream<T> {\n    public function new(?def : Deferred<T>){\n        super(def);\n    }\n    inline public function resolve(val:T){\n        this.handleResolve(val);\n    }\n    inline public function update(val:T){\n        this.handleResolve(val);\n    }\n    inline public static function publicstream<T>(val:T){\n        var ps = new PublicStream();\n        ps.resolve(val);\n        return ps;\n    }\n}\n","package promhx.base;\n\nclass EventLoop {\n    static var queue : List<Void->Void> = new List();\n    // public static var nextLoop(default, set) : (Void->Void)-> Void;\n    public static var nextLoop : (Void->Void)-> Void;\n\n#if (js && !nodejs && !noEmbedJs && !noEmbedSetImmediate)\n    static function __init__() untyped {\n#if !nodejs\n        // we need to use global as an alternate since setImmediate expects this == window\n        var global = window;\n#end\n        haxe.macro.Compiler.includeFile(\"lib/setImmediate/setImmediate.js\");\n    }\n#end\n\n    public static inline function enqueue(eqf:Void->Void)  {\n        queue.add(eqf);\n        continueOnNextLoop();\n    }\n    static function set_nextLoop(f : (Void->Void)->Void) : (Void->Void)->Void{\n        if (nextLoop != null) throw \"nextLoop has already been set\";\n        else nextLoop = f;\n        return nextLoop;\n    }\n\n    /**\n      Retrieve the current length of the queue.\n     **/\n    public static function queueLength() {\n        return queue.length;\n    }\n\n    /**\n      Attempt to finish the remaining loops in the queue.  Returns true\n      if all loops are finished.  If [max_iterations] pass, then exit and\n      return false.\n     **/\n    public static function finish(max_iterations = 1000){\n        while (queue.length > 0 && max_iterations-- > 0){\n            queue.pop()();\n        }\n        return queue.length == 0;\n    }\n\n    /**\n      Clear the existing event loop queue.\n     **/\n    public static function clear(){\n        queue = new List();\n    }\n\n    static function continueOnNextLoop(){\n        var f = function(){\n            if (queue.length > 0) {\n                queue.pop()();\n                continueOnNextLoop();\n            }\n        }\n        if (nextLoop != null) nextLoop(f);\n        else {\n\n#if flash\n            haxe.Timer.delay(f,0);\n#elseif (js && (noEmbedJs || noEmbedSetImmediate) && !nodejs)\n            // fallback to setTimeout\n            untyped __js__(\"(typeof setImmediate === 'function' ? setImmediate : setTimeout)\")(f);\n#elseif js\n            // use polyfill or native node\n            untyped __js__(\"setImmediate\")(f);\n#else\n            f();\n#end\n        }\n    }\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n\tThis class defines mathematical functions and constants.\n**/\n#if cpp @:include(\"hxMath\") #end\nextern class Math\n{\n\t/**\n\t\tRepresents the ratio of the circumference of a circle to its diameter, \n\t\tspecified by the constant, . `PI` is approximately 3.141592653589793.\n\t**/\n\tstatic var PI(default,null) : Float;\n\n\t/**\n\t\tA special Float constant which denotes negative infinity.\n\n\t\tFor example, this is the result of -1.0 / 0.0.\n\n\t\tOperations with NEGATIVE_INFINITY as an operand may result in\n\t\tNEGATIVE_INFINITY, POSITIVE_INFINITY or NaN. \n\n\t\tIf this constant is converted to an Int, e.g. through Std.int(), the\n\t\tresult is unspecified.\n\t**/\n\tstatic var NEGATIVE_INFINITY(default, null) : Float;\n\n\t/**\n\t\tA special Float constant which denotes negative infinity.\n\n\t\tFor example, this is the result of 1.0 / 0.0.\n\n\t\tOperations with POSITIVE_INFINITY as an operand may result in\n\t\tNEGATIVE_INFINITY, POSITIVE_INFINITY or NaN. \n\n\t\tIf this constant is converted to an Int, e.g. through Std.int(), the\n\t\tresult is unspecified.\n\t**/\n\tstatic var POSITIVE_INFINITY(default,null) : Float;\n\n\t/**\n\t\tA special Float constant which denotes an invalid number.\n\n\t\tNaN stands for \"Not a Number\". It occurs when a mathematically incorrect\n\t\toperation is executed, such as taking the square root of a negative\n\t\tnumber: Math.sqrt(-1).\n\n\t\tAll further operations with NaN as an operand will result in NaN.\n\n\t\tIf this constant is converted to an Int, e.g. through Std.int(), the\n\t\tresult is unspecified.\n\n\t\tIn order to test if a value is NaN, you should use Math.isNaN() function.\n\n\t\t@php In PHP versions prior to 5.3.1 VC 9 there may be unexpected\n\t\tresults when performing arithmetic operations with NaN on Windows, \n\t\tsee [https://bugs.php.net/bug.php?id=42143]\n\t**/\n\tstatic var NaN(default, null) : Float;\n\n\t/**\n\t\tReturns the absolute value of `v`.\n\n\t\tIf `v` is positive or 0, the result is unchanged. Otherwise the result \n\t\tis -`v`.\n\t\t\n\t\tIf `v` is NEGATIVE_INFINITY or POSITIVE_INFINITY, the result is \n\t\tPOSITIVE_INFINITY.\n\t\t\n\t\tIf `v` is NaN, the result is NaN.\n\t**/\n\tstatic function abs(v:Float):Float;\n\n\t/**\n\t\tReturns the smaller of values `a` and `b`.\n\n\t\tIf `a` or `b` are NaN, the result is NaN.\n\t\tIf `a` or `b` are NEGATIVE_INFINITY, the result is NEGATIVE_INFINITY.\n\t\tIf `a` and `b` are POSITIVE_INFINITY, the result is POSITIVE_INFINITY.\n\t**/\n\tstatic function min(a:Float, b:Float):Float;\n\n\t/**\n\t\tReturns the greater of values `a` and `b`.\n\n\t\tIf `a` or `b` are NaN, the result is NaN.\n\t\tIf `a` or `b` are POSITIVE_INFINITY, the result is POSITIVE_INFINITY.\n\t\tIf `a` and `b` are NEGATIVE_INFINITY, the result is NEGATIVE_INFINITY.\n\t**/\n\tstatic function max(a:Float, b:Float):Float;\n\n\t/**\n\t\tReturns the trigonometric sine of the specified angle `v`, in radians.\n\t\t\n\t\tIf `v` is NaN or infinite, the result is NaN.\n\t**/\n\tstatic function sin(v:Float):Float;\n\n\t/**\n\t\tReturns the trigonometric cosine of the specified angle `v`, in radians.\n\t\t\n\t\tIf `v` is NaN or infinite, the result is NaN.\n\t**/\n\tstatic function cos(v:Float):Float;\n\n\t/**\n\t\tReturns the trigonometric tangent of the specified angle `v`, in radians.\n\t\t\n\t\tIf `v` is NaN or infinite, the result is NaN.\n\t**/\n\tstatic function tan(v:Float):Float;\n\n\t/**\n\t\tReturns the trigonometric arc of the specified angle `v`, in radians.\n\t\t\n\t\tIf `v` is NaN or infinite, the result is NaN.\n\t**/\n\tstatic function asin(v:Float):Float;\n\n\t/**\n\t\tReturns the trigonometric arc cosine of the specified angle `v`, \n\t\tin radians.\n\t\t\n\t\tIf `v` is NaN or infinite, the result is NaN.\n\t**/\n\tstatic function acos(v:Float):Float;\n\n\t/**\n\t\tReturns the trigonometric arc tangent of the specified angle `v`, \n\t\tin radians.\n\t\t\n\t\tIf `v` is NaN or infinite, the result is NaN.\n\t**/\n\tstatic function atan(v:Float):Float;\n\n\t/**\n\t\tReturns the trigonometric arc tangent whose tangent is the quotient of \n\t\ttwo specified numbers, in radians.\n\t\t\n\t\tIf parameter `x` or `y`  is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, \n\t\tthe result is NaN.\n\t**/\n\tstatic function atan2(y:Float, x:Float):Float;\n\n\t/**\n\t\tReturns Euler's number, raised to the power of `v`.\n\t\t\n\t\texp(1.0) is approximately 2.718281828459.\n\t\t\n\t\tIf `v` is POSITIVE_INFINITY, the result is POSITIVE_INFINITY.\n\t\tIf `v` is NEGATIVE_INFINITY, the result is 0.0.\n\t\tIf `v` is NaN, the result is NaN.\n\t**/\n\tstatic function exp(v:Float):Float;\n\n\t/**\n\t\tReturns the natural logarithm of `v`.\n\t\t\n\t\tThis is the mathematical inverse operation of exp, \n\t\ti.e. `log(exp(v)) == v` always holds.\n\t\t\n\t\tIf `v` is negative (including NEGATIVE_INFINITY) or NaN, the result \n\t\tis NaN.\n\t\tIf `v` is POSITIVE_INFINITY, the result is POSITIVE_INFINITY.\n\t\tIf `v` is 0.0, the result is NEGATIVE_INFINITY.\n\t**/\n\tstatic function log(v:Float):Float;\n\n\t/**\n\t\tReturns a specified base `v` raised to the specified power `exp`.\n\t**/\n\tstatic function pow(v:Float, exp:Float):Float;\n\n\t/**\n\t\tReturns the square root of `v`.\n\t\t\n\t\tIf `v` is negative (including NEGATIVE_INFINITY) or NaN, the result \n\t\tis NaN.\n\t\tIf `v` is POSITIVE_INFINITY, the result is POSITIVE_INFINITY.\n\t\tIf `v` is 0.0, the result is 0.0.\n\t**/\n\tstatic function sqrt(v:Float):Float;\n\n\t/**\n\t\tRounds `v` to the nearest integer value.\n\t\t\n\t\tIf `v` is outside of the signed Int32 range, or is NaN, NEGATIVE_INFINITY \n\t\tor POSITIVE_INFINITY, the result is unspecified.\n\t**/\n\tstatic function round(v:Float):Int;\n\n\t/**\n\t\tReturns the largest integer value that is not greater than `v`.\n\n\t\tIf `v` is outside of the signed Int32 range, or is NaN, NEGATIVE_INFINITY \n\t\tor POSITIVE_INFINITY, the result is unspecified.\n\t**/\n\tstatic function floor(v:Float):Int;\n\n\t/**\n\t\tReturns the smallest integer value that is not less than `v`.\n\n\t\tIf `v` is outside of the signed Int32 range, or is NaN, NEGATIVE_INFINITY \n\t\tor POSITIVE_INFINITY, the result is unspecified.\n\t**/\n\tstatic function ceil(v:Float):Int;\n\n\t/**\n\t\tReturns a pseudo-random number which is greater than or equal to 0.0, \n\t\tand less than 1.0.\n\t**/\n\tstatic function random() : Float;\n\n\t#if ((flash9 && !as3) || cpp)\n\t/**\n\t\tReturns the largest integer value that is not greater than `v`, as a Float.\n\n\t\tIf `v` is is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, \n\t\tthe result is unspecified.\n\t**/\n\tstatic function ffloor( v : Float ) : Float;\n\n\t/**\n\t\tReturns the smallest integer value that is not less than `v`, as a Float.\n\n\t\tIf `v` is is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, \n\t\tthe result is unspecified.\n\t**/\n\tstatic function fceil( v : Float ) : Float;\n\n\t/**\n\t\tRounds `v` to the nearest integer value, as a Float.\n\n\t\tIf `v` is is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, \n\t\tthe result is unspecified.\n\t**/\n\tstatic function fround( v : Float ) : Float;\n\n\t#else\n\n\tstatic inline function ffloor( v : Float ) : Float {\n\t\treturn floor(v);\n\t}\n\n\tstatic inline function fceil( v : Float ) : Float {\n\t\treturn ceil(v);\n\t}\n\n\tstatic inline function fround( v : Float ) : Float {\n\t\treturn round(v);\n\t}\n\n\t#end\n\n\n\t/**\n\t\tTells if `f` is a finite number.\n\n\t\tIf `f` is POSITIVE_INFINITY, NEGATIVE_INFINITY or NaN, the result \n\t\tis false, otherwise the result is true.\n\t**/\n\tstatic function isFinite( f : Float ) : Bool;\n\n\t/**\n\t\tTells if `f` is not a valid number.\n\n\t\tIf `f` is NaN, the result is true, otherwise the result is false. \n\t\tIn particular, both POSITIVE_INFINITY and NEGATIVE_INFINITY are\n\t\tnot considered NaN.\n\t**/\n\tstatic function isNaN( f : Float ) : Bool;\n\n\tprivate static function __init__() : Void untyped {\n\t#if flash9\n\t\tNaN = __global__[\"Number\"].NaN;\n\t\tNEGATIVE_INFINITY = __global__[\"Number\"].NEGATIVE_INFINITY;\n\t\tPOSITIVE_INFINITY = __global__[\"Number\"].POSITIVE_INFINITY;\n\t#else\n\t\t#if !js // genjs.ml will insert this only if necessary.\n\t\t\tMath.__name__ = [\"Math\"];\n\t\t#end\n\t\tMath.NaN = Number[\"NaN\"];\n\t\tMath.NEGATIVE_INFINITY = Number[\"NEGATIVE_INFINITY\"];\n\t\tMath.POSITIVE_INFINITY = Number[\"POSITIVE_INFINITY\"];\n\t#end\n\t#if js\n\t\t__feature__(\"Type.resolveClass\",$hxClasses['Math'] = Math);\n\t#end\n\t\tMath.isFinite = function(i) {\n\t\t\treturn\n\t\t\t#if flash9\n\t\t\t__global__[\"isFinite\"](i);\n\t\t\t#elseif flash\n\t\t\t_global[\"isFinite\"](i);\n\t\t\t#elseif js\n\t\t\t__js__(\"isFinite\")(i);\n\t\t\t#else\n\t\t\tfalse;\n\t\t\t#end\n\t\t};\n\t\tMath.isNaN = function(i) {\n\t\t\treturn\n\t\t\t#if flash9\n\t\t\t__global__[\"isNaN\"](i);\n\t\t\t#elseif flash\n\t\t\t_global[\"isNaN\"](i);\n\t\t\t#elseif js\n\t\t\t__js__(\"isNaN\")(i);\n\t\t\t#else\n\t\t\tfalse;\n\t\t\t#end\n\t\t};\n\t}\n\n}\n\n\n","\npackage npm;\n\n#if macro\nimport haxe.Json;\nimport haxe.macro.Compiler;\nimport haxe.macro.Context;\nimport haxe.macro.Expr;\nimport haxe.macro.Expr.Field;\nimport sys.io.File;\n#end\n\nprivate typedef Pack = {\n\tname : String,\n\t?version : String\n}\n\n#if !macro extern #end\nclass Package {\n\n\tstatic var dependencies : #if haxe3 Map<String,String> #else Hash<String> #end;\n\n\t#if macro\n\tpublic static function export( path : String = \"package.json\" ) : Void{\n\t\tContext.onGenerate( function(_){\n\t\t\tif( dependencies == null ) return;\n\t\t\tvar data : Dynamic = {}\n\t\t\t\n\t\t\tif( sys.FileSystem.exists(path) ){\n\t\t\t\tdata = Json.parse( File.getContent(path) );\n\t\t\t}\n\n\t\t\tif( data.dependencies == null ){\n\t\t\t\tdata.dependencies = {};\n\t\t\t}else{\n\t\t\t\tswitch(Type.typeof(data.dependencies)){\n\t\t\t\t\tcase TObject: // fine\n\t\t\t\t\tdefault: data.dependencies = {};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor( name in dependencies.keys() ){\n\t\t\t\tReflect.setField( data.dependencies , name , dependencies.get(name) );\n\t\t\t}\n\n\t\t\tvar content =  haxe.Json.stringify( data );\n\t\t\tsys.io.File.saveContent( path , content );\n\n\t\t});\n\t}\n\t#end\n\t\n\t#if haxe3 macro #else @:macro #end public static function require( name : String , ?version : String = \"*\" , ?isNpm : Bool = true , ?native : String = null ) {\n\t\t\n\t\tif( dependencies == null ){\n\t\t\tdependencies = new #if haxe3 Map #else Hash #end();\n\t\t}\n\t\t\n\t\tvar nameExpr = Context.makeExpr( name , Context.currentPos() );\n\t\t\n\t\tif( isNpm )\n\t\t\tdependencies.set( name , version );\n\n\t\tvar outp = macro __js__(\"require\")( $nameExpr );\n\t\t\n\t\tif( native != null ){\n\t\t\tfor( p in native.split(\".\") ){\n\t\t\t\tvar pExpr = Context.makeExpr( p , Context.currentPos() );\n\t\t\t\toutp = macro $outp[$pExpr];\n\t\t\t}\n\n\t\t}\n\n\t\treturn macro untyped $outp;\n\t\t\n\t}\n\n\t#if haxe3 macro #else @:macro #end public static function resolve( expr , path : String ) {\n\t\tfor( p in path.split(\".\") ){\n\t\t\tvar pExpr = Context.makeExpr( p , Context.currentPos() );\n\t\t\texpr = macro $expr[$pExpr];\n\t\t}\n\n\t\treturn macro $expr;\n\t}\n\t\n\t\n}\n\n#if !macro extern #end class Include {\n\n\t#if macro\n\tstatic var requireId = 0;\n\tstatic inline var NPM_DONE_META = ':npm_done';\n\tstatic inline var USAGE = \"Usage: 'implements npm.Require<\\\"module-name\\\",\\\"module-version\\\">'\";\n\tstatic inline var NPM_REQUIRE = \"npm.Package.Require\";\n\tstatic inline var NPM_REQUIRE_NAMESPACE = \"npm.Package.RequireNamespace\";\n\tstatic inline var NPM_OPTION_FULL_PATH = \"npm_full_path\";\n\tstatic inline var JS_NODE_PACKAGE  = 'js.node';\n\tstatic inline var SEP = \"__\";\n\tstatic inline var INIT = \"__init__\";\n\t#end\n\n\t#if haxe3 macro #else @:macro #end public static function build() : Array<Field>{\n\t\t\n\t\tvar cl = Context.getLocalClass().get();\n\t\tvar fields = Context.getBuildFields();\n\t\tvar required : Pack = null;\n\t\tvar requireNS = false;\n\t\tvar pos = Context.currentPos();\n\t\tvar isNpm = !( cl.pack.slice(0,2).join('.') == JS_NODE_PACKAGE );\n\n\t\t// see if the type has already been processed\n\t\tif( cl.meta.has(NPM_DONE_META) )\n\t\t\treturn fields;\n\t\n\t\t// mark the type as processed\n\t\tcl.meta.add( NPM_DONE_META , [] , pos );\n\t\t\n\t\t// extract infos from the implemented interfaces\n\t\t/*t.module == NPM_PACKAGE_MODULE\n\t\t\t\t&& ( t.name == NPM_CLASS_REQUIRE || t.name == NPM_CLASS_REQUIRE_NAMESPACE ) */\n\n\t\tvar requireParams = util.Macro.extractStringParams( cl , NPM_REQUIRE );\n\t\tif( requireParams.length == 0 ){\n\t\t\trequireParams = util.Macro.extractStringParams( cl , NPM_REQUIRE_NAMESPACE );\n\t\t\trequireNS = true;\n\t\t}\n\n\t\tif( requireParams.length > 0 ){\n\n\t\t\trequired = {\n\t\t\t\tname : requireParams[0][0],\n\t\t\t\tversion : requireParams[0][1]\n\t\t\t};\n\n\t\t\t// exclude local files\n\t\t\tisNpm = isNpm && !( StringTools.startsWith(required.name,'/') || StringTools.startsWith(required.name,'./') );\n\t\t\t\n\t\t\t// set the generated class name \n\t\t\tvar clName = if( !Context.defined( NPM_OPTION_FULL_PATH ) )\n\t\t\t\t// if minified\n\t\t\t\tcl.name+SEP+(requireId++);\n\t\t\telse\n\t\t\t\t// if not, use the class' full path\n\t\t\t\tcl.pack.join(SEP) + SEP+cl.name;\n\n\t\t\t// initialization expressions\n\t\t\tvar init = [];\n\n\t\t\t// use the type name by default\n\t\t\tvar nativeClass = cl.name;\n\n\t\t\tif( requireNS ){\n\t\t\t\t// if the package is a namespace\n\t\t\t\t\n\t\t\t\t// check for :native class name\n\t\t\t\tvar _nativeName = util.Macro.extractNative( cl );\n\t\t\t\tif( _nativeName != null ){\n\t\t\t\t\tnativeClass = _nativeName;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif( requireNS )\n\t\t\t\tinit.push( macro var $clName = untyped npm.Package.resolve( npm.Package.require( '${required.name}','${required.version}' , $v{isNpm} ) , '${nativeClass}' ) );\n\t\t\telse\n\t\t\t\tinit.push( macro var $clName = untyped npm.Package.require( '${required.name}','${required.version}' , $v{isNpm} ) );\n\n\t\t\t// change the class' native name\n\t\t\tvar native = 'require(\"${required.name}\")';\n\t\t\tif( requireNS ){\n\t\t\t\tnative = native + '.${nativeClass}';\n\t\t\t}\n\t\t\tnative = '$clName';\n\t\t\t\n\t\t\tcl.meta.add(\":native\",[macro $v{native}], pos);\n\n\t\t\t// inject the initiatization code in __init__\n\t\t\tvar injected = false;\n\n\t\t\t// check that __init__ method already exists\n\t\t\tfor( f in fields ){\n\t\t\t\tif( f.name == INIT ){\n\t\t\t\t\tswitch( f.kind ){\n\t\t\t\t\t\tcase FFun( fun ) :\n\t\t\t\t\t\t\tinjected = true;\n\t\t\t\t\t\t\t// add the existing __init__ body in the end of the generated init expression\n\t\t\t\t\t\t\tinit.push( { expr : fun.expr.expr , pos : fun.expr.pos } );\n\t\t\t\t\t\t\tvar newExpr = {\n\t\t\t\t\t\t\t\tpos : fun.expr.pos,\n\t\t\t\t\t\t\t\texpr : EBlock(init)\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tfun.expr = newExpr;\n\t\t\t\t\t\tdefault :\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// if __init__ doesn't exist, just add the whole method\n\t\t\tif( !injected ){\n\t\t\t\tvar f = {\n\t\t\t\t\tname : INIT,\n\t\t\t\t\tpos : pos,\n\t\t\t\t\tmeta : [],\n\t\t\t\t\taccess : [AStatic],\n\t\t\t\t\tkind : FFun({\n\t\t\t\t\t\tret : TPath({\n\t\t\t\t\t\t\tname : \"Void\",\n\t\t\t\t\t\t\tpack : [],\n\t\t\t\t\t\t\tparams : [],\n\t\t\t\t\t\t\tsub : null\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tparams : [],\n\t\t\t\t\t\targs : [],\n\t\t\t\t\t\texpr : {\n\t\t\t\t\t\t\tpos : pos,\n\t\t\t\t\t\t\texpr : EBlock(init)\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t};\n\t\t\t\tfields.push(f);\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\treturn fields;\n\t}\n\t\n}\n\n@:autoBuild(npm.Include.build())\nextern interface Require<Const,Const> {}\n\n@:autoBuild(npm.Include.build())\nextern interface RequireNamespace<Const,Const> {}\n\n","/* Same license as Node.js\n   Maintainer: Ritchie Turner, ritchie@async.cl\n\n   Node.js 0.8 api without haXe embellishments so that other apis may be implemented\n   on top without being hindered by design choices here.\n\n   Domain not added.\n*/\n\npackage js;\n\nclass Node {  \n\n  public static var console(default,null) : js.node.stdio.Console = untyped __js__('console');\n  public static var process(default,null) : js.node.Process = untyped __js__('process');\n  public static var module(default,null) : Dynamic = untyped __js__('module');\n  public static var exports : Dynamic = untyped __js__('exports');\n  public static var __filename(default,null) : String = untyped __js__('__filename');\n  public static var __dirname(default,null) : String = untyped __js__('__dirname');\n\n  public static var require(default,null): String->Dynamic = untyped __js__(\"require\");\n  public static var setTimeout(default,null): (Void->Void)->Int->?Array<String>->Int = untyped __js__(\"setTimeout\");\n  public static var setInterval(default,null): (Void->Void)->Int->?Array<String>->Int = untyped __js__(\"setInterval\");\n  public static var clearTimeout(default,null): Int->Void = untyped __js__(\"clearTimeout\");\n  public static var clearInterval(default,null): Int->Void = untyped __js__(\"clearInterval\");\n\n}\n\n\n"],
"names":[],
"mappings":"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"
}