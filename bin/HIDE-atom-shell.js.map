{
"version":3,
"file":"HIDE-atom-shell.js",
"sourceRoot":"file://",
"sources":["/home/as3boyan/HIDE-atom-shell/src/AtomShellMain.hx","/home/as3boyan/HIDE-atom-shell/externs/haxe-js-kit/js/atomshell/browser/BrowserWindow.hx","/home/as3boyan/HIDE-atom-shell/externs/haxe-js-kit/atomshell/Package.hx","/home/as3boyan/HIDE-atom-shell/externs/haxe-js-kit/npm/Package.hx","/home/as3boyan/HIDE-atom-shell/externs/haxe-js-kit/js/Node.hx"],
"sourcesContent":["package ;\nimport js.atomshell.browser.App;\nimport js.atomshell.browser.BrowserWindow;\nimport js.Lib;\n\nclass AtomShellMain\n{\n    static public function main()\n    {\n\t\tvar mainBrowserWindow = null;\n\t\t\n\t\tApp.on(AppEvent.WINDOW_ALL_CLOSED, function ()\n\t\t\t   {\n\t\t\t\t   if (js.Node.process.platform != \"darwin\")\n\t\t\t\t   {\n\t\t\t\t\t   App.quit();\n\t\t\t\t   }\n\t\t\t   }\n\t\t\t  );\n\t\t\n\t\tApp.on(AppEvent.READY, function ()\n\t\t\t{\t\t\t\t\n// \t\t\t\tvar size = Screen.getPrimaryDisplay().workAreaSize;\n\t\t\t\t\n\t\t\t\tvar windowOptions:BrowserWindowOptions = new BrowserWindowOptions();\n// \t\t\t\twindowOptions.skipTaskbar = true;\n// \t\t\t\twindowOptions.center = true;\n// \t\t\t\twindowOptions.width = size.width;\n// \t\t\t\twindowOptions.height = size.height;\n\t\t\t\t\n\t\t\t\tmainBrowserWindow = new BrowserWindow(windowOptions);\n\t\t\t\t\n\t\t\t\tmainBrowserWindow.loadUrl(\"file://\" + js.Node.__dirname + \"/index.html\");\n\t\t\t\t\n\t\t\t\tmainBrowserWindow.on(BrowserWindowEvent.CLOSED, function ()\n\t\t\t\t\t{\n\t\t\t\t\t\tmainBrowserWindow = null;\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\t\n// \t\t\t\tmainBrowserWindow.webContents.on(BrowserWindow.WebContentsEvent.DID_FINISH_LOAD, function ()\n// \t\t\t\t\t{\n\t\t\t\t\t\t\n// \t\t\t\t\t});\n\t\t\t\t\n// \t\t\t\tMain.load();\n\t\t\t\t\n\t\t\t\tmainBrowserWindow.toggleDevTools();\n\t\t\t}\n\t\t);\n\n\t}\n}","package js.atomshell.browser;\nimport js.node.events.EventEmitter;\n\n/**\n* @author AS3Boyan\n */\n@:enum\nabstract BrowserWindowNodeIntegration(String) to String\n{\n    var ALL = \"all\";\n    var EXCEPT_IFRAME = \"except-iframe\";\n    var MANUAL_ENABLE_IFRAME = \"manual-enable-iframe\";\n}\n\nclass BrowserWindowWebPreferences\n{\n\tpublic var javascript:Bool;\n\tpublic var images:Bool;\n\tpublic var java:Bool;\n\tpublic var webgl:Bool;\n\tpublic var webaudio:Bool;\n\tpublic var plugins:Bool;\n\t\n\tpublic var webSecurity(never, set):Bool;\n\tpublic var textAreasAreResizable(never, set):Bool;\n\tpublic var acceleratedCompositing(never, set):Bool;\n\tpublic var extraPluginDirs(never, set):Array<String>;\n\t\n\tfunction set_webSecurity(value:Bool)\n\t{\n\t\treturn untyped this[\"web-security\"] = value;\n\t}\n\t\n\tfunction set_textAreasAreResizable(value:Bool)\n\t{\n\t\treturn untyped this[\"text-areas-are-resizable\"] = value;\n\t}\n\t\n\tfunction set_acceleratedCompositing(value:Bool)\n\t{\n\t\treturn untyped this[\"accelerated-compositing\"] = value;\n\t}\n\t\n\tfunction set_extraPluginDirs(value:Array<String>)\n\t{\n\t\treturn untyped this[\"extra-plugin-dirs\"] = value;\n\t}\n}\n\nclass BrowserWindowOptions\n{\n\tpublic var width:Int;\n\tpublic var height:Int;\n\tpublic var x:Int;\n\tpublic var y:Int;\n\tpublic var center:Bool;\n\tpublic var resizable:Bool;\n\tpublic var fullscreen:Bool;\n\tpublic var kiosk:Bool;\n\tpublic var title:String;\n\tpublic var icon:String;\n\tpublic var show:Bool;\n\tpublic var frame:Bool;\n\t\n\tpublic var skipTaskbar(never, set):Bool;\n\tpublic var zoomFactor(never, set):Float;\n\tpublic var alwaysOnTop(never, set):Bool;\n\tpublic var useContentSize(never, set):Bool;\n\tpublic var minWidth(never, set):Int;\n\tpublic var minHeight(never, set):Int;\n\tpublic var maxWidth(never, set):Int;\n\tpublic var maxHeight(never, set):Int;\n\tpublic var nodeIntegration(never, set):BrowserWindowNodeIntegration;\n\tpublic var acceptFirstMouse(never, set):Bool;\n\tpublic var webPreferences(get, set):BrowserWindowWebPreferences;\n\t\n\tfunction set_skipTaskbar(value:Bool)\n\t{\n\t\treturn untyped this[\"skip-taskbar\"] = value;\n\t}\n\n\tfunction set_zoomFactor(value:Float)\n\t{\n\t\treturn untyped this[\"zoom-factor\"] = value;\n\t}\n\n\tfunction set_alwaysOnTop(value:Bool)\n\t{\n\t\treturn untyped this[\"always-on-top\"] = value;\n\t}\n\n\tfunction set_useContentSize(value:Bool)\n\t{\n\t\treturn untyped this[\"use-content-size\"] = value;\n\t}\n\n\tfunction set_minWidth(value:Int)\n\t{\n\t\treturn untyped this[\"min-width\"] = value;\n\t}\n\n\tfunction set_minHeight(value:Int)\n\t{\n\t\treturn untyped this[\"min-height\"] = value;\n\t}\n\n\tfunction set_maxWidth(value:Int)\n\t{\n\t\treturn untyped this[\"max-width\"] = value;\n\t}\n\n\tfunction set_maxHeight(value:Int)\n\t{\n\t\treturn untyped this[\"max-height\"] = value;\n\t}\n\n\tfunction set_nodeIntegration(value:BrowserWindowNodeIntegration)\n\t{\n\t\treturn untyped this[\"node-integration\"] = value;\n\t}\n\n\tfunction set_acceptFirstMouse(value:Bool)\n\t{\n\t\treturn untyped this[\"accept-first-mouse\"] = value;\n\t}\n\n\tfunction set_webPreferences(value:BrowserWindowWebPreferences)\n\t{\n\t\treturn untyped this[\"web-preferences\"] = value;\n\t}\n\t\n\tfunction get_webPreferences()\n\t{\n\t\treturn untyped this[\"web-preferences\"];\n\t}\n\t\n\tpublic function new()\n\t{\n\t\t\n\t}\n}\n\nextern class BrowserWindow implements atomshell.Package.Require<\"browser-window\",\"*\"> extends EventEmitter\n{\n\tvar webContents:BrowserWindowWebContents;\n\tvar devToolsWebContents:BrowserWindowWebContents;\n\tvar id:Int;\n\t\n\tfunction new(options:BrowserWindowOptions);\n\tfunction loadUrl(path:String):Void;\n\tfunction destroy():Void;\n\tfunction close():Void;\n\tfunction focus():Void;\n\tfunction isFocused():Bool;\n\tfunction show():Void;\n\tfunction hide():Void;\n\tfunction isVisible():Bool;\n\tfunction maximize():Void;\n\tfunction unmaximize():Void;\n\tfunction minimize():Void;\n\tfunction restore():Void;\n\tfunction setFullScreen(flag:Bool):Void;\n\tfunction isFullScreen():Bool;\n\tfunction setSize(width:Int, height:Int):Void;\n\tfunction getSize():Array<Int>;\n\tfunction setContentSize(width:Int, height:Int):Void;\n\tfunction getContentSize():Array<Int>;\n\tfunction setMinimumSize(width:Int, height:Int):Void;\n\tfunction getMinimumSize():Array<Int>;\n\tfunction setMaximumSize(width:Int, height:Int):Void;\n\tfunction getMaximumSize():Array<Int>;\n\tfunction setResizable(resizable:Bool):Void;\n\tfunction isResizable():Bool;\n\tfunction setAlwaysOnTop(flag:Bool):Void;\n\tfunction isAlwaysOnTop():Bool;\n\tfunction center():Void;\n\tfunction setPosition(x:Int, y:Int):Void;\n\tfunction getPosition():Array<Int>;\n\tfunction setTitle(title:String):Void;\n\tfunction getTitle():String;\n\tfunction flashFrame():Void;\n\tfunction setSkipTaskbar(skip:Bool):Void;\n\tfunction setKiosk(flag:Bool):Void;\n\tfunction isKiosk():Bool;\n\t/* OS X Only */\n\tfunction setRepresentedFilename(filename:String):Void;\n\t/* OS X Only */\n\tfunction setDocumentEdited(edited:Bool):Void;\n\tfunction openDevTools():Void;\n\tfunction closeDevTools():Void;\n\tfunction inspectElement(x:Int, y:Int):Void;\n\tfunction focusOnWebView():Void;\n\tfunction blurWebView():Void;\n\tfunction capturePage(?rect:{x:Int, y:Int, width:Int, height:Int}, cb:Dynamic->Void):Void;\n\tfunction reload():Void;\n\t/* Note: This API is not available on OS X. */\n\tfunction setMenu(menu:Dynamic):Void;\n\tfunction toggleDevTools():Void;\n\t\n\tstatic function getAllWindows():Array<BrowserWindow>;\n\tstatic function getFocusedWindow():Array<BrowserWindow>;\n\tstatic function fromWebContents():BrowserWindow;\n\tstatic function fromId(id:Int):BrowserWindow;\n}\n\n@:enum \nabstract BrowserWindowEvent(String) to String\n{\n\tvar CLOSED = \"closed\";\n\tvar PAGE_TITLE_UPDATED = \"page-title-updated\";\n\tvar CLOSE = \"close\";\n\tvar UNRESPONSIVE = \"unresponsive\";\n\tvar RESPONSIVE = \"responsive\";\n\tvar BLUR = \"blur\";\n\tvar FOCUS = \"focus\";\t\n}\n\nextern class BrowserWindowWebContents extends EventEmitter\n{\n\tfunction loadUrl(url:String):Void;\n\tfunction getUrl():String;\n\tfunction getTitle():String;\n\tfunction isLoading():Bool;\n\tfunction isWaitingForResponse():Bool;\n\tfunction stop():Void;\n\tfunction reload():Void;\n\tfunction reloadIgnoringCache():Void;\n\tfunction canGoBack():Bool;\n\tfunction canGoForward():Bool;\n\tfunction canGoToOffset(offset:Int):Bool;\n\tfunction goBack():Void;\n\tfunction goForward():Void;\n\tfunction goToIndex(index:Int):Void;\n\tfunction goToOffset(offset:Int):Void;\n\tfunction IsCrashed():Bool;\n\tfunction executeJavaScript(code:String):Void;\n\tfunction send(channel:String, ?args:Dynamic):Void;\n}\n\n@:enum\nabstract WebContentsEvent(String) to String\n{\n\tvar CLOSED = \"crashed\";\n\tvar DID_FINISH_LOAD = \"did-finish-load\";\n\tvar DID_FRAME_FINISH_LOAD = \"did-frame-finish-load\";\n\tvar DID_START_LOADING = \"did-start-loading\";\n\tvar DID_STOP_LOADING = \"did-stop-loading\";\n}","\npackage atomshell;\n\n#if macro\nimport haxe.Json;\nimport haxe.macro.Compiler;\nimport haxe.macro.Context;\nimport haxe.macro.Expr;\nimport haxe.macro.Expr.Field;\nimport sys.io.File;\n#end\n\nprivate typedef Pack = {\n\tname : String,\n\t?version : String\n}\n\n#if !macro extern #end\nclass Package {\n\n\tstatic var dependencies : #if haxe3 Map<String,String> #else Hash<String> #end;\n\n\t#if macro\n\tpublic static function export( path : String = \"package.json\" ) : Void{\n\t\tContext.onGenerate( function(_){\n\t\t\tif( dependencies == null ) return;\n\t\t\tvar data : Dynamic = {}\n\t\t\t\n\t\t\tif( sys.FileSystem.exists(path) ){\n\t\t\t\tdata = Json.parse( File.getContent(path) );\n\t\t\t}\n\n\t\t\tif( data.dependencies == null ){\n\t\t\t\tdata.dependencies = {};\n\t\t\t}else{\n\t\t\t\tswitch(Type.typeof(data.dependencies)){\n\t\t\t\t\tcase TObject: // fine\n\t\t\t\t\tdefault: data.dependencies = {};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor( name in dependencies.keys() ){\n\t\t\t\tReflect.setField( data.dependencies , name , dependencies.get(name) );\n\t\t\t}\n\n\t\t\tvar content =  haxe.Json.stringify( data );\n\t\t\tsys.io.File.saveContent( path , content );\n\n\t\t});\n\t}\n\t#end\n\t\n\t#if haxe3 macro #else @:macro #end public static function require( name : String , ?version : String = \"*\" , ?isNpm : Bool = true , ?native : String = null ) {\n\t\t\n\t\tif( dependencies == null ){\n\t\t\tdependencies = new #if haxe3 Map #else Hash #end();\n\t\t}\n\t\t\n\t\tvar nameExpr = Context.makeExpr( name , Context.currentPos() );\n\t\t\n\t\tif( isNpm )\n\t\t\tdependencies.set( name , version );\n\n\t\t#if !webpage\n\t\t\tvar outp = macro __js__(\"require\")( $nameExpr );\n\t\t#else\n\t\t\tvar outp = macro __js__(\"require('remote').require\")( $nameExpr );\n\t\t#end\t\t\n\n\t\tif( native != null ){\n\t\t\tfor( p in native.split(\".\") ){\n\t\t\t\tvar pExpr = Context.makeExpr( p , Context.currentPos() );\n\t\t\t\toutp = macro $outp[$pExpr];\n\t\t\t}\n\n\t\t}\n\n\t\treturn macro untyped $outp;\n\t\t\n\t}\n\n\t#if haxe3 macro #else @:macro #end public static function resolve( expr , path : String ) {\n\t\tfor( p in path.split(\".\") ){\n\t\t\tvar pExpr = Context.makeExpr( p , Context.currentPos() );\n\t\t\texpr = macro $expr[$pExpr];\n\t\t}\n\n\t\treturn macro $expr;\n\t}\n\t\n\t\n}\n\n#if !macro extern #end class Include {\n\n\t#if macro\n\tstatic var requireId = 0;\n\tstatic inline var NPM_DONE_META = ':npm_done2';\n\tstatic inline var USAGE = \"Usage: 'implements atomshell.Require<\\\"module-name\\\",\\\"module-version\\\">'\";\n\tstatic inline var NPM_REQUIRE = \"atomshell.Package.Require\";\n\tstatic inline var NPM_REQUIRE_NAMESPACE = \"atomshell.Package.RequireNamespace\";\n\tstatic inline var NPM_OPTION_FULL_PATH = \"npm_full_path\";\n\tstatic inline var JS_NODE_PACKAGE  = 'js.node';\n\tstatic inline var SEP = \"__\";\n\tstatic inline var INIT = \"__init__\";\n\t#end\n\n\t#if haxe3 macro #else @:macro #end public static function build() : Array<Field>{\n\t\t\n\t\tvar cl = Context.getLocalClass().get();\n\t\tvar fields = Context.getBuildFields();\n\t\tvar required : Pack = null;\n\t\tvar requireNS = false;\n\t\tvar pos = Context.currentPos();\n\t\tvar isNpm = !( cl.pack.slice(0,2).join('.') == JS_NODE_PACKAGE );\n\n\t\t// see if the type has already been processed\n\t\tif( cl.meta.has(NPM_DONE_META) )\n\t\t\treturn fields;\n\t\n\t\t// mark the type as processed\n\t\tcl.meta.add( NPM_DONE_META , [] , pos );\n\t\t\n\t\t// extract infos from the implemented interfaces\n\t\t/*t.module == NPM_PACKAGE_MODULE\n\t\t\t\t&& ( t.name == NPM_CLASS_REQUIRE || t.name == NPM_CLASS_REQUIRE_NAMESPACE ) */\n\n\t\tvar requireParams = util.Macro.extractStringParams( cl , NPM_REQUIRE );\n\t\tif( requireParams.length == 0 ){\n\t\t\trequireParams = util.Macro.extractStringParams( cl , NPM_REQUIRE_NAMESPACE );\n\t\t\trequireNS = true;\n\t\t}\n\n\t\tif( requireParams.length > 0 ){\n\n\t\t\trequired = {\n\t\t\t\tname : requireParams[0][0],\n\t\t\t\tversion : requireParams[0][1]\n\t\t\t};\n\n\t\t\t// exclude local files\n\t\t\tisNpm = isNpm && !( StringTools.startsWith(required.name,'/') || StringTools.startsWith(required.name,'./') );\n\t\t\t\n\t\t\t// set the generated class name \n\t\t\tvar clName = if( !Context.defined( NPM_OPTION_FULL_PATH ) )\n\t\t\t\t// if minified\n\t\t\t\tcl.name+SEP+(requireId++);\n\t\t\telse\n\t\t\t\t// if not, use the class' full path\n\t\t\t\tcl.pack.join(SEP) + SEP+cl.name;\n\n\t\t\t// initialization expressions\n\t\t\tvar init = [];\n\n\t\t\t// use the type name by default\n\t\t\tvar nativeClass = cl.name;\n\n\t\t\tif( requireNS ){\n\t\t\t\t// if the package is a namespace\n\t\t\t\t\n\t\t\t\t// check for :native class name\n\t\t\t\tvar _nativeName = util.Macro.extractNative( cl );\n\t\t\t\tif( _nativeName != null ){\n\t\t\t\t\tnativeClass = _nativeName;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif( requireNS )\n\t\t\t\tinit.push( macro var $clName = untyped atomshell.Package.resolve( atomshell.Package.require( '${required.name}','${required.version}' , $v{isNpm} ) , '${nativeClass}' ) );\n\t\t\telse\n\t\t\t\tinit.push( macro var $clName = untyped atomshell.Package.require( '${required.name}','${required.version}' , $v{isNpm} ) );\n\n\t\t\t// change the class' native name\n\t\t\tvar native = 'require(\"${required.name}\")';\n\t\t\tif( requireNS ){\n\t\t\t\tnative = native + '.${nativeClass}';\n\t\t\t}\n\t\t\tnative = '$clName';\n\t\t\t\n\t\t\tcl.meta.add(\":native\",[macro $v{native}], pos);\n\n\t\t\t// inject the initiatization code in __init__\n\t\t\tvar injected = false;\n\n\t\t\t// check that __init__ method already exists\n\t\t\tfor( f in fields ){\n\t\t\t\tif( f.name == INIT ){\n\t\t\t\t\tswitch( f.kind ){\n\t\t\t\t\t\tcase FFun( fun ) :\n\t\t\t\t\t\t\tinjected = true;\n\t\t\t\t\t\t\t// add the existing __init__ body in the end of the generated init expression\n\t\t\t\t\t\t\tinit.push( { expr : fun.expr.expr , pos : fun.expr.pos } );\n\t\t\t\t\t\t\tvar newExpr = {\n\t\t\t\t\t\t\t\tpos : fun.expr.pos,\n\t\t\t\t\t\t\t\texpr : EBlock(init)\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tfun.expr = newExpr;\n\t\t\t\t\t\tdefault :\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// if __init__ doesn't exist, just add the whole method\n\t\t\tif( !injected ){\n\t\t\t\tvar f = {\n\t\t\t\t\tname : INIT,\n\t\t\t\t\tpos : pos,\n\t\t\t\t\tmeta : [],\n\t\t\t\t\taccess : [AStatic],\n\t\t\t\t\tkind : FFun({\n\t\t\t\t\t\tret : TPath({\n\t\t\t\t\t\t\tname : \"Void\",\n\t\t\t\t\t\t\tpack : [],\n\t\t\t\t\t\t\tparams : [],\n\t\t\t\t\t\t\tsub : null\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tparams : [],\n\t\t\t\t\t\targs : [],\n\t\t\t\t\t\texpr : {\n\t\t\t\t\t\t\tpos : pos,\n\t\t\t\t\t\t\texpr : EBlock(init)\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t};\n\t\t\t\tfields.push(f);\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\treturn fields;\n\t}\n\t\n}\n\n@:autoBuild(atomshell.Include.build())\nextern interface Require<Const,Const> {}\n\n@:autoBuild(atomshell.Include.build())\nextern interface RequireNamespace<Const,Const> {}\n\n","\npackage npm;\n\n#if macro\nimport haxe.Json;\nimport haxe.macro.Compiler;\nimport haxe.macro.Context;\nimport haxe.macro.Expr;\nimport haxe.macro.Expr.Field;\nimport sys.io.File;\n#end\n\nprivate typedef Pack = {\n\tname : String,\n\t?version : String\n}\n\n#if !macro extern #end\nclass Package {\n\n\tstatic var dependencies : #if haxe3 Map<String,String> #else Hash<String> #end;\n\n\t#if macro\n\tpublic static function export( path : String = \"package.json\" ) : Void{\n\t\tContext.onGenerate( function(_){\n\t\t\tif( dependencies == null ) return;\n\t\t\tvar data : Dynamic = {}\n\t\t\t\n\t\t\tif( sys.FileSystem.exists(path) ){\n\t\t\t\tdata = Json.parse( File.getContent(path) );\n\t\t\t}\n\n\t\t\tif( data.dependencies == null ){\n\t\t\t\tdata.dependencies = {};\n\t\t\t}else{\n\t\t\t\tswitch(Type.typeof(data.dependencies)){\n\t\t\t\t\tcase TObject: // fine\n\t\t\t\t\tdefault: data.dependencies = {};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor( name in dependencies.keys() ){\n\t\t\t\tReflect.setField( data.dependencies , name , dependencies.get(name) );\n\t\t\t}\n\n\t\t\tvar content =  haxe.Json.stringify( data );\n\t\t\tsys.io.File.saveContent( path , content );\n\n\t\t});\n\t}\n\t#end\n\t\n\t#if haxe3 macro #else @:macro #end public static function require( name : String , ?version : String = \"*\" , ?isNpm : Bool = true , ?native : String = null ) {\n\t\t\n\t\tif( dependencies == null ){\n\t\t\tdependencies = new #if haxe3 Map #else Hash #end();\n\t\t}\n\t\t\n\t\tvar nameExpr = Context.makeExpr( name , Context.currentPos() );\n\t\t\n\t\tif( isNpm )\n\t\t\tdependencies.set( name , version );\n\n\t\tvar outp = macro __js__(\"require\")( $nameExpr );\n\t\t\n\t\tif( native != null ){\n\t\t\tfor( p in native.split(\".\") ){\n\t\t\t\tvar pExpr = Context.makeExpr( p , Context.currentPos() );\n\t\t\t\toutp = macro $outp[$pExpr];\n\t\t\t}\n\n\t\t}\n\n\t\treturn macro untyped $outp;\n\t\t\n\t}\n\n\t#if haxe3 macro #else @:macro #end public static function resolve( expr , path : String ) {\n\t\tfor( p in path.split(\".\") ){\n\t\t\tvar pExpr = Context.makeExpr( p , Context.currentPos() );\n\t\t\texpr = macro $expr[$pExpr];\n\t\t}\n\n\t\treturn macro $expr;\n\t}\n\t\n\t\n}\n\n#if !macro extern #end class Include {\n\n\t#if macro\n\tstatic var requireId = 0;\n\tstatic inline var NPM_DONE_META = ':npm_done';\n\tstatic inline var USAGE = \"Usage: 'implements npm.Require<\\\"module-name\\\",\\\"module-version\\\">'\";\n\tstatic inline var NPM_REQUIRE = \"npm.Package.Require\";\n\tstatic inline var NPM_REQUIRE_NAMESPACE = \"npm.Package.RequireNamespace\";\n\tstatic inline var NPM_OPTION_FULL_PATH = \"npm_full_path\";\n\tstatic inline var JS_NODE_PACKAGE  = 'js.node';\n\tstatic inline var SEP = \"__\";\n\tstatic inline var INIT = \"__init__\";\n\t#end\n\n\t#if haxe3 macro #else @:macro #end public static function build() : Array<Field>{\n\t\t\n\t\tvar cl = Context.getLocalClass().get();\n\t\tvar fields = Context.getBuildFields();\n\t\tvar required : Pack = null;\n\t\tvar requireNS = false;\n\t\tvar pos = Context.currentPos();\n\t\tvar isNpm = !( cl.pack.slice(0,2).join('.') == JS_NODE_PACKAGE );\n\n\t\t// see if the type has already been processed\n\t\tif( cl.meta.has(NPM_DONE_META) )\n\t\t\treturn fields;\n\t\n\t\t// mark the type as processed\n\t\tcl.meta.add( NPM_DONE_META , [] , pos );\n\t\t\n\t\t// extract infos from the implemented interfaces\n\t\t/*t.module == NPM_PACKAGE_MODULE\n\t\t\t\t&& ( t.name == NPM_CLASS_REQUIRE || t.name == NPM_CLASS_REQUIRE_NAMESPACE ) */\n\n\t\tvar requireParams = util.Macro.extractStringParams( cl , NPM_REQUIRE );\n\t\tif( requireParams.length == 0 ){\n\t\t\trequireParams = util.Macro.extractStringParams( cl , NPM_REQUIRE_NAMESPACE );\n\t\t\trequireNS = true;\n\t\t}\n\n\t\tif( requireParams.length > 0 ){\n\n\t\t\trequired = {\n\t\t\t\tname : requireParams[0][0],\n\t\t\t\tversion : requireParams[0][1]\n\t\t\t};\n\n\t\t\t// exclude local files\n\t\t\tisNpm = isNpm && !( StringTools.startsWith(required.name,'/') || StringTools.startsWith(required.name,'./') );\n\t\t\t\n\t\t\t// set the generated class name \n\t\t\tvar clName = if( !Context.defined( NPM_OPTION_FULL_PATH ) )\n\t\t\t\t// if minified\n\t\t\t\tcl.name+SEP+(requireId++);\n\t\t\telse\n\t\t\t\t// if not, use the class' full path\n\t\t\t\tcl.pack.join(SEP) + SEP+cl.name;\n\n\t\t\t// initialization expressions\n\t\t\tvar init = [];\n\n\t\t\t// use the type name by default\n\t\t\tvar nativeClass = cl.name;\n\n\t\t\tif( requireNS ){\n\t\t\t\t// if the package is a namespace\n\t\t\t\t\n\t\t\t\t// check for :native class name\n\t\t\t\tvar _nativeName = util.Macro.extractNative( cl );\n\t\t\t\tif( _nativeName != null ){\n\t\t\t\t\tnativeClass = _nativeName;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif( requireNS )\n\t\t\t\tinit.push( macro var $clName = untyped npm.Package.resolve( npm.Package.require( '${required.name}','${required.version}' , $v{isNpm} ) , '${nativeClass}' ) );\n\t\t\telse\n\t\t\t\tinit.push( macro var $clName = untyped npm.Package.require( '${required.name}','${required.version}' , $v{isNpm} ) );\n\n\t\t\t// change the class' native name\n\t\t\tvar native = 'require(\"${required.name}\")';\n\t\t\tif( requireNS ){\n\t\t\t\tnative = native + '.${nativeClass}';\n\t\t\t}\n\t\t\tnative = '$clName';\n\t\t\t\n\t\t\tcl.meta.add(\":native\",[macro $v{native}], pos);\n\n\t\t\t// inject the initiatization code in __init__\n\t\t\tvar injected = false;\n\n\t\t\t// check that __init__ method already exists\n\t\t\tfor( f in fields ){\n\t\t\t\tif( f.name == INIT ){\n\t\t\t\t\tswitch( f.kind ){\n\t\t\t\t\t\tcase FFun( fun ) :\n\t\t\t\t\t\t\tinjected = true;\n\t\t\t\t\t\t\t// add the existing __init__ body in the end of the generated init expression\n\t\t\t\t\t\t\tinit.push( { expr : fun.expr.expr , pos : fun.expr.pos } );\n\t\t\t\t\t\t\tvar newExpr = {\n\t\t\t\t\t\t\t\tpos : fun.expr.pos,\n\t\t\t\t\t\t\t\texpr : EBlock(init)\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tfun.expr = newExpr;\n\t\t\t\t\t\tdefault :\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// if __init__ doesn't exist, just add the whole method\n\t\t\tif( !injected ){\n\t\t\t\tvar f = {\n\t\t\t\t\tname : INIT,\n\t\t\t\t\tpos : pos,\n\t\t\t\t\tmeta : [],\n\t\t\t\t\taccess : [AStatic],\n\t\t\t\t\tkind : FFun({\n\t\t\t\t\t\tret : TPath({\n\t\t\t\t\t\t\tname : \"Void\",\n\t\t\t\t\t\t\tpack : [],\n\t\t\t\t\t\t\tparams : [],\n\t\t\t\t\t\t\tsub : null\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tparams : [],\n\t\t\t\t\t\targs : [],\n\t\t\t\t\t\texpr : {\n\t\t\t\t\t\t\tpos : pos,\n\t\t\t\t\t\t\texpr : EBlock(init)\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t};\n\t\t\t\tfields.push(f);\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\treturn fields;\n\t}\n\t\n}\n\n@:autoBuild(npm.Include.build())\nextern interface Require<Const,Const> {}\n\n@:autoBuild(npm.Include.build())\nextern interface RequireNamespace<Const,Const> {}\n\n","/* Same license as Node.js\n   Maintainer: Ritchie Turner, ritchie@async.cl\n\n   Node.js 0.8 api without haXe embellishments so that other apis may be implemented\n   on top without being hindered by design choices here.\n\n   Domain not added.\n*/\n\npackage js;\n\nclass Node {  \n\n  public static var console(default,null) : js.node.stdio.Console = untyped __js__('console');\n  public static var process(default,null) : js.node.Process = untyped __js__('process');\n  public static var module(default,null) : Dynamic = untyped __js__('module');\n  public static var exports : Dynamic = untyped __js__('exports');\n  public static var __filename(default,null) : String = untyped __js__('__filename');\n  public static var __dirname(default,null) : String = untyped __js__('__dirname');\n\n  public static var require(default,null): String->Dynamic = untyped __js__(\"require\");\n  public static var setTimeout(default,null): (Void->Void)->Int->?Array<String>->Int = untyped __js__(\"setTimeout\");\n  public static var setInterval(default,null): (Void->Void)->Int->?Array<String>->Int = untyped __js__(\"setInterval\");\n  public static var clearTimeout(default,null): Int->Void = untyped __js__(\"clearTimeout\");\n  public static var clearInterval(default,null): Int->Void = untyped __js__(\"clearInterval\");\n\n}\n\n\n"],
"names":[],
"mappings":";;qBAOiB,VACd;CACsB;CAExB,AAAO,AAA4B,UAE9B;EAAI,EAA4B,HAE/B;;CAKN,AAAO,AAAgB,UACtB;EAG0C;EAMzC,CAAoB,kBAAkB;EAEtC,DAA0B,EAAY,AAAoB;EAE1D,DAAqB,AAA2B,UAE9C;GAAoB;;EAWtB;;;;;;;4CCyFI,jCACP;;ACzEmB,CA0GuB;AC1F3B,GAjBG,FAqG6C;ADpG5C,CA0GuB;AC1F3B,GAjBG,FAqG6C;AApFhD,GAjBG,FAqG6C;kBCtJM;oBAIP;;;;"
}