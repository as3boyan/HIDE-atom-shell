{
"version":3,
"file":"HIDE-atom-shell.js",
"sourceRoot":"file://",
"sources":["/home/as3boyan/HIDE-atom-shell/src/AtomShellMain.hx","/home/as3boyan/HIDE-atom-shell/externs/haxe-js-kit/atomshell/Package.hx","/home/as3boyan/HIDE-atom-shell/externs/haxe-js-kit/npm/Package.hx","/home/as3boyan/HIDE-atom-shell/externs/haxe-js-kit/js/Node.hx"],
"sourcesContent":["package ;\nimport js.Node;\nimport js.atomshell.browser.App;\nimport js.atomshell.browser.BrowserWindow;\nimport js.Lib;\n\nclass AtomShellMain\n{\n    static public function main()\n    {\n\t\tvar mainBrowserWindow = null;\n\t\t\n\t\tNode.process.chdir(Node.__dirname);\n\t\t\n\t\tApp.commandLine.appendSwitch('js-flags', '--harmony');\n\n\t\tApp.on(AppEvent.WINDOW_ALL_CLOSED, function ()\n\t\t\t   {\n\t\t\t\t   if (js.Node.process.platform != \"darwin\")\n\t\t\t\t   {\n\t\t\t\t\t   App.quit();\n\t\t\t\t   }\n\t\t\t   }\n\t\t\t  );\n\t\t\n\t\tApp.on(AppEvent.READY, function ()\n\t\t\t{\n\t\t\t\tvar windowOptions:BrowserWindowOptions = {};\n\t\t\t\twindowOptions.minWidth = 768;\n\t\t\t\twindowOptions.minHeight = 300;\n\t\t\t\t\n\t\t\t\twindowOptions.icon = \"HIDE.png\";\n\t\t\t\t\n\t\t\t\tmainBrowserWindow = new BrowserWindow(windowOptions);\n\t\t\t\t\n\t\t\t\tmainBrowserWindow.loadUrl(\"file://\" + js.Node.__dirname + \"/index.html\");\n\t\t\t\t\n\t\t\t\tmainBrowserWindow.on(BrowserWindowEvent.CLOSED, function ()\n\t\t\t\t\t{\n\t\t\t\t\t\tmainBrowserWindow = null;\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\t\n\t\t\t\tmainBrowserWindow.toggleDevTools();\n\t\t\t}\n\t\t);\n\n\t}\n}\n","\npackage atomshell;\n\n#if macro\nimport haxe.Json;\nimport haxe.macro.Compiler;\nimport haxe.macro.Context;\nimport haxe.macro.Expr;\nimport haxe.macro.Expr.Field;\nimport sys.io.File;\n#end\n\nprivate typedef Pack = {\n\tname : String,\n\t?version : String\n}\n\n#if !macro extern #end\nclass Package {\n\n\tstatic var dependencies : #if haxe3 Map<String,String> #else Hash<String> #end;\n\n\t#if macro\n\tpublic static function export( path : String = \"package.json\" ) : Void{\n\t\tContext.onGenerate( function(_){\n\t\t\tif( dependencies == null ) return;\n\t\t\tvar data : Dynamic = {}\n\t\t\t\n\t\t\tif( sys.FileSystem.exists(path) ){\n\t\t\t\tdata = Json.parse( File.getContent(path) );\n\t\t\t}\n\n\t\t\tif( data.dependencies == null ){\n\t\t\t\tdata.dependencies = {};\n\t\t\t}else{\n\t\t\t\tswitch(Type.typeof(data.dependencies)){\n\t\t\t\t\tcase TObject: // fine\n\t\t\t\t\tdefault: data.dependencies = {};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor( name in dependencies.keys() ){\n\t\t\t\tReflect.setField( data.dependencies , name , dependencies.get(name) );\n\t\t\t}\n\n\t\t\tvar content =  haxe.Json.stringify( data );\n\t\t\tsys.io.File.saveContent( path , content );\n\n\t\t});\n\t}\n\t#end\n\t\n\t#if haxe3 macro #else @:macro #end public static function require( name : String , ?version : String = \"*\" , ?isNpm : Bool = true , ?native : String = null ) {\n\t\t\n\t\tif( dependencies == null ){\n\t\t\tdependencies = new #if haxe3 Map #else Hash #end();\n\t\t}\n\t\t\n\t\tvar nameExpr = Context.makeExpr( name , Context.currentPos() );\n\t\t\n\t\tif( isNpm )\n\t\t\tdependencies.set( name , version );\n\n\t\t#if !webpage\n\t\t\tvar outp = macro __js__(\"require\")( $nameExpr );\n\t\t#else\n\t\t\tvar outp = macro __js__(\"require('remote').require\")( $nameExpr );\n\t\t#end\t\t\n\n\t\tif( native != null ){\n\t\t\tfor( p in native.split(\".\") ){\n\t\t\t\tvar pExpr = Context.makeExpr( p , Context.currentPos() );\n\t\t\t\toutp = macro $outp[$pExpr];\n\t\t\t}\n\n\t\t}\n\n\t\treturn macro untyped $outp;\n\t\t\n\t}\n\n\t#if haxe3 macro #else @:macro #end public static function resolve( expr , path : String ) {\n\t\tfor( p in path.split(\".\") ){\n\t\t\tvar pExpr = Context.makeExpr( p , Context.currentPos() );\n\t\t\texpr = macro $expr[$pExpr];\n\t\t}\n\n\t\treturn macro $expr;\n\t}\n\t\n\t\n}\n\n#if !macro extern #end class Include {\n\n\t#if macro\n\tstatic var requireId = 0;\n\tstatic inline var NPM_DONE_META = ':npm_done2';\n\tstatic inline var USAGE = \"Usage: 'implements atomshell.Require<\\\"module-name\\\",\\\"module-version\\\">'\";\n\tstatic inline var NPM_REQUIRE = \"atomshell.Package.Require\";\n\tstatic inline var NPM_REQUIRE_NAMESPACE = \"atomshell.Package.RequireNamespace\";\n\tstatic inline var NPM_OPTION_FULL_PATH = \"npm_full_path\";\n\tstatic inline var JS_NODE_PACKAGE  = 'js.node';\n\tstatic inline var SEP = \"__\";\n\tstatic inline var INIT = \"__init__\";\n\t#end\n\n\t#if haxe3 macro #else @:macro #end public static function build() : Array<Field>{\n\t\t\n\t\tvar cl = Context.getLocalClass().get();\n\t\tvar fields = Context.getBuildFields();\n\t\tvar required : Pack = null;\n\t\tvar requireNS = false;\n\t\tvar pos = Context.currentPos();\n\t\tvar isNpm = !( cl.pack.slice(0,2).join('.') == JS_NODE_PACKAGE );\n\n\t\t// see if the type has already been processed\n\t\tif( cl.meta.has(NPM_DONE_META) )\n\t\t\treturn fields;\n\t\n\t\t// mark the type as processed\n\t\tcl.meta.add( NPM_DONE_META , [] , pos );\n\t\t\n\t\t// extract infos from the implemented interfaces\n\t\t/*t.module == NPM_PACKAGE_MODULE\n\t\t\t\t&& ( t.name == NPM_CLASS_REQUIRE || t.name == NPM_CLASS_REQUIRE_NAMESPACE ) */\n\n\t\tvar requireParams = util.Macro.extractStringParams( cl , NPM_REQUIRE );\n\t\tif( requireParams.length == 0 ){\n\t\t\trequireParams = util.Macro.extractStringParams( cl , NPM_REQUIRE_NAMESPACE );\n\t\t\trequireNS = true;\n\t\t}\n\n\t\tif( requireParams.length > 0 ){\n\n\t\t\trequired = {\n\t\t\t\tname : requireParams[0][0],\n\t\t\t\tversion : requireParams[0][1]\n\t\t\t};\n\n\t\t\t// exclude local files\n\t\t\tisNpm = isNpm && !( StringTools.startsWith(required.name,'/') || StringTools.startsWith(required.name,'./') );\n\t\t\t\n\t\t\t// set the generated class name \n\t\t\tvar clName = if( !Context.defined( NPM_OPTION_FULL_PATH ) )\n\t\t\t\t// if minified\n\t\t\t\tcl.name+SEP+(requireId++);\n\t\t\telse\n\t\t\t\t// if not, use the class' full path\n\t\t\t\tcl.pack.join(SEP) + SEP+cl.name;\n\n\t\t\t// initialization expressions\n\t\t\tvar init = [];\n\n\t\t\t// use the type name by default\n\t\t\tvar nativeClass = cl.name;\n\n\t\t\tif( requireNS ){\n\t\t\t\t// if the package is a namespace\n\t\t\t\t\n\t\t\t\t// check for :native class name\n\t\t\t\tvar _nativeName = util.Macro.extractNative( cl );\n\t\t\t\tif( _nativeName != null ){\n\t\t\t\t\tnativeClass = _nativeName;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif( requireNS )\n\t\t\t\tinit.push( macro var $clName = untyped atomshell.Package.resolve( atomshell.Package.require( '${required.name}','${required.version}' , $v{isNpm} ) , '${nativeClass}' ) );\n\t\t\telse\n\t\t\t\tinit.push( macro var $clName = untyped atomshell.Package.require( '${required.name}','${required.version}' , $v{isNpm} ) );\n\n\t\t\t// change the class' native name\n\t\t\tvar native = 'require(\"${required.name}\")';\n\t\t\tif( requireNS ){\n\t\t\t\tnative = native + '.${nativeClass}';\n\t\t\t}\n\t\t\tnative = '$clName';\n\t\t\t\n\t\t\tcl.meta.add(\":native\",[macro $v{native}], pos);\n\n\t\t\t// inject the initiatization code in __init__\n\t\t\tvar injected = false;\n\n\t\t\t// check that __init__ method already exists\n\t\t\tfor( f in fields ){\n\t\t\t\tif( f.name == INIT ){\n\t\t\t\t\tswitch( f.kind ){\n\t\t\t\t\t\tcase FFun( fun ) :\n\t\t\t\t\t\t\tinjected = true;\n\t\t\t\t\t\t\t// add the existing __init__ body in the end of the generated init expression\n\t\t\t\t\t\t\tinit.push( { expr : fun.expr.expr , pos : fun.expr.pos } );\n\t\t\t\t\t\t\tvar newExpr = {\n\t\t\t\t\t\t\t\tpos : fun.expr.pos,\n\t\t\t\t\t\t\t\texpr : EBlock(init)\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tfun.expr = newExpr;\n\t\t\t\t\t\tdefault :\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// if __init__ doesn't exist, just add the whole method\n\t\t\tif( !injected ){\n\t\t\t\tvar f = {\n\t\t\t\t\tname : INIT,\n\t\t\t\t\tpos : pos,\n\t\t\t\t\tmeta : [],\n\t\t\t\t\taccess : [AStatic],\n\t\t\t\t\tkind : FFun({\n\t\t\t\t\t\tret : TPath({\n\t\t\t\t\t\t\tname : \"Void\",\n\t\t\t\t\t\t\tpack : [],\n\t\t\t\t\t\t\tparams : [],\n\t\t\t\t\t\t\tsub : null\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tparams : [],\n\t\t\t\t\t\targs : [],\n\t\t\t\t\t\texpr : {\n\t\t\t\t\t\t\tpos : pos,\n\t\t\t\t\t\t\texpr : EBlock(init)\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t};\n\t\t\t\tfields.push(f);\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\treturn fields;\n\t}\n\t\n}\n\n@:autoBuild(atomshell.Include.build())\nextern interface Require<Const,Const> {}\n\n@:autoBuild(atomshell.Include.build())\nextern interface RequireNamespace<Const,Const> {}\n\n","\npackage npm;\n\n#if macro\nimport haxe.Json;\nimport haxe.macro.Compiler;\nimport haxe.macro.Context;\nimport haxe.macro.Expr;\nimport haxe.macro.Expr.Field;\nimport sys.io.File;\n#end\n\nprivate typedef Pack = {\n\tname : String,\n\t?version : String\n}\n\n#if !macro extern #end\nclass Package {\n\n\tstatic var dependencies : #if haxe3 Map<String,String> #else Hash<String> #end;\n\n\t#if macro\n\tpublic static function export( path : String = \"package.json\" ) : Void{\n\t\tContext.onGenerate( function(_){\n\t\t\tif( dependencies == null ) return;\n\t\t\tvar data : Dynamic = {}\n\t\t\t\n\t\t\tif( sys.FileSystem.exists(path) ){\n\t\t\t\tdata = Json.parse( File.getContent(path) );\n\t\t\t}\n\n\t\t\tif( data.dependencies == null ){\n\t\t\t\tdata.dependencies = {};\n\t\t\t}else{\n\t\t\t\tswitch(Type.typeof(data.dependencies)){\n\t\t\t\t\tcase TObject: // fine\n\t\t\t\t\tdefault: data.dependencies = {};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor( name in dependencies.keys() ){\n\t\t\t\tReflect.setField( data.dependencies , name , dependencies.get(name) );\n\t\t\t}\n\n\t\t\tvar content =  haxe.Json.stringify( data );\n\t\t\tsys.io.File.saveContent( path , content );\n\n\t\t});\n\t}\n\t#end\n\t\n\t#if haxe3 macro #else @:macro #end public static function require( name : String , ?version : String = \"*\" , ?isNpm : Bool = true , ?native : String = null ) {\n\t\t\n\t\tif( dependencies == null ){\n\t\t\tdependencies = new #if haxe3 Map #else Hash #end();\n\t\t}\n\t\t\n\t\tvar nameExpr = Context.makeExpr( name , Context.currentPos() );\n\t\t\n\t\tif( isNpm )\n\t\t\tdependencies.set( name , version );\n\n\t\tvar outp = macro __js__(\"require\")( $nameExpr );\n\t\t\n\t\tif( native != null ){\n\t\t\tfor( p in native.split(\".\") ){\n\t\t\t\tvar pExpr = Context.makeExpr( p , Context.currentPos() );\n\t\t\t\toutp = macro $outp[$pExpr];\n\t\t\t}\n\n\t\t}\n\n\t\treturn macro untyped $outp;\n\t\t\n\t}\n\n\t#if haxe3 macro #else @:macro #end public static function resolve( expr , path : String ) {\n\t\tfor( p in path.split(\".\") ){\n\t\t\tvar pExpr = Context.makeExpr( p , Context.currentPos() );\n\t\t\texpr = macro $expr[$pExpr];\n\t\t}\n\n\t\treturn macro $expr;\n\t}\n\t\n\t\n}\n\n#if !macro extern #end class Include {\n\n\t#if macro\n\tstatic var requireId = 0;\n\tstatic inline var NPM_DONE_META = ':npm_done';\n\tstatic inline var USAGE = \"Usage: 'implements npm.Require<\\\"module-name\\\",\\\"module-version\\\">'\";\n\tstatic inline var NPM_REQUIRE = \"npm.Package.Require\";\n\tstatic inline var NPM_REQUIRE_NAMESPACE = \"npm.Package.RequireNamespace\";\n\tstatic inline var NPM_OPTION_FULL_PATH = \"npm_full_path\";\n\tstatic inline var JS_NODE_PACKAGE  = 'js.node';\n\tstatic inline var SEP = \"__\";\n\tstatic inline var INIT = \"__init__\";\n\t#end\n\n\t#if haxe3 macro #else @:macro #end public static function build() : Array<Field>{\n\t\t\n\t\tvar cl = Context.getLocalClass().get();\n\t\tvar fields = Context.getBuildFields();\n\t\tvar required : Pack = null;\n\t\tvar requireNS = false;\n\t\tvar pos = Context.currentPos();\n\t\tvar isNpm = !( cl.pack.slice(0,2).join('.') == JS_NODE_PACKAGE );\n\n\t\t// see if the type has already been processed\n\t\tif( cl.meta.has(NPM_DONE_META) )\n\t\t\treturn fields;\n\t\n\t\t// mark the type as processed\n\t\tcl.meta.add( NPM_DONE_META , [] , pos );\n\t\t\n\t\t// extract infos from the implemented interfaces\n\t\t/*t.module == NPM_PACKAGE_MODULE\n\t\t\t\t&& ( t.name == NPM_CLASS_REQUIRE || t.name == NPM_CLASS_REQUIRE_NAMESPACE ) */\n\n\t\tvar requireParams = util.Macro.extractStringParams( cl , NPM_REQUIRE );\n\t\tif( requireParams.length == 0 ){\n\t\t\trequireParams = util.Macro.extractStringParams( cl , NPM_REQUIRE_NAMESPACE );\n\t\t\trequireNS = true;\n\t\t}\n\n\t\tif( requireParams.length > 0 ){\n\n\t\t\trequired = {\n\t\t\t\tname : requireParams[0][0],\n\t\t\t\tversion : requireParams[0][1]\n\t\t\t};\n\n\t\t\t// exclude local files\n\t\t\tisNpm = isNpm && !( StringTools.startsWith(required.name,'/') || StringTools.startsWith(required.name,'./') );\n\t\t\t\n\t\t\t// set the generated class name \n\t\t\tvar clName = if( !Context.defined( NPM_OPTION_FULL_PATH ) )\n\t\t\t\t// if minified\n\t\t\t\tcl.name+SEP+(requireId++);\n\t\t\telse\n\t\t\t\t// if not, use the class' full path\n\t\t\t\tcl.pack.join(SEP) + SEP+cl.name;\n\n\t\t\t// initialization expressions\n\t\t\tvar init = [];\n\n\t\t\t// use the type name by default\n\t\t\tvar nativeClass = cl.name;\n\n\t\t\tif( requireNS ){\n\t\t\t\t// if the package is a namespace\n\t\t\t\t\n\t\t\t\t// check for :native class name\n\t\t\t\tvar _nativeName = util.Macro.extractNative( cl );\n\t\t\t\tif( _nativeName != null ){\n\t\t\t\t\tnativeClass = _nativeName;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif( requireNS )\n\t\t\t\tinit.push( macro var $clName = untyped npm.Package.resolve( npm.Package.require( '${required.name}','${required.version}' , $v{isNpm} ) , '${nativeClass}' ) );\n\t\t\telse\n\t\t\t\tinit.push( macro var $clName = untyped npm.Package.require( '${required.name}','${required.version}' , $v{isNpm} ) );\n\n\t\t\t// change the class' native name\n\t\t\tvar native = 'require(\"${required.name}\")';\n\t\t\tif( requireNS ){\n\t\t\t\tnative = native + '.${nativeClass}';\n\t\t\t}\n\t\t\tnative = '$clName';\n\t\t\t\n\t\t\tcl.meta.add(\":native\",[macro $v{native}], pos);\n\n\t\t\t// inject the initiatization code in __init__\n\t\t\tvar injected = false;\n\n\t\t\t// check that __init__ method already exists\n\t\t\tfor( f in fields ){\n\t\t\t\tif( f.name == INIT ){\n\t\t\t\t\tswitch( f.kind ){\n\t\t\t\t\t\tcase FFun( fun ) :\n\t\t\t\t\t\t\tinjected = true;\n\t\t\t\t\t\t\t// add the existing __init__ body in the end of the generated init expression\n\t\t\t\t\t\t\tinit.push( { expr : fun.expr.expr , pos : fun.expr.pos } );\n\t\t\t\t\t\t\tvar newExpr = {\n\t\t\t\t\t\t\t\tpos : fun.expr.pos,\n\t\t\t\t\t\t\t\texpr : EBlock(init)\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tfun.expr = newExpr;\n\t\t\t\t\t\tdefault :\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// if __init__ doesn't exist, just add the whole method\n\t\t\tif( !injected ){\n\t\t\t\tvar f = {\n\t\t\t\t\tname : INIT,\n\t\t\t\t\tpos : pos,\n\t\t\t\t\tmeta : [],\n\t\t\t\t\taccess : [AStatic],\n\t\t\t\t\tkind : FFun({\n\t\t\t\t\t\tret : TPath({\n\t\t\t\t\t\t\tname : \"Void\",\n\t\t\t\t\t\t\tpack : [],\n\t\t\t\t\t\t\tparams : [],\n\t\t\t\t\t\t\tsub : null\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tparams : [],\n\t\t\t\t\t\targs : [],\n\t\t\t\t\t\texpr : {\n\t\t\t\t\t\t\tpos : pos,\n\t\t\t\t\t\t\texpr : EBlock(init)\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t};\n\t\t\t\tfields.push(f);\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\treturn fields;\n\t}\n\t\n}\n\n@:autoBuild(npm.Include.build())\nextern interface Require<Const,Const> {}\n\n@:autoBuild(npm.Include.build())\nextern interface RequireNamespace<Const,Const> {}\n\n","/* Same license as Node.js\n   Maintainer: Ritchie Turner, ritchie@async.cl\n\n   Node.js 0.8 api without haXe embellishments so that other apis may be implemented\n   on top without being hindered by design choices here.\n\n   Domain not added.\n*/\n\npackage js;\n\nclass Node {  \n\n  public static var console(default,null) : js.node.stdio.Console = untyped __js__('console');\n  public static var process(default,null) : js.node.Process = untyped __js__('process');\n  public static var module(default,null) : Dynamic = untyped __js__('module');\n  public static var exports : Dynamic = untyped __js__('exports');\n  public static var __filename(default,null) : String = untyped __js__('__filename');\n  public static var __dirname(default,null) : String = untyped __js__('__dirname');\n\n  public static var require(default,null): String->Dynamic = untyped __js__(\"require\");\n  public static var setTimeout(default,null): (Void->Void)->Int->?Array<String>->Int = untyped __js__(\"setTimeout\");\n  public static var setInterval(default,null): (Void->Void)->Int->?Array<String>->Int = untyped __js__(\"setInterval\");\n  public static var clearTimeout(default,null): Int->Void = untyped __js__(\"clearTimeout\");\n  public static var clearInterval(default,null): Int->Void = untyped __js__(\"clearInterval\");\n\n}\n\n\n"],
"names":[],
"mappings":";;qBAQiB,VACd;CACsB;CAExB,AAAmB;CAEnB,AAA8B,AAAY;CAE1C,AAAO,AAA4B,UAE9B;EAAI,EAA4B,HAE/B;;CAKN,AAAO,AAAgB,UACtB;EACC;EAAyC;EAAzC;;;;;;;;;;;;;;;;;;;;;;;;;EACA,CAAyB;EACzB,CAA0B;EAE1B,CAAqB;EAErB,CAAoB,kBAAkB;EAEtC,DAA0B,EAAY,AAAoB;EAE1D,DAAqB,AAA2B,UAE9C;GAAoB;;EAItB;;;;;ACqBgB,CA0GuB;AC1F3B,GAjBG,FAqG6C;ADpG5C,CA0GuB;AC1F3B,GAjBG,FAqG6C;AApFhD,GAjBG,FAqG6C;kBCtJM;oBAIP;;;;"
}